<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Composability in functional and flow-based programming | Living Systems</title>

      <link rel="stylesheet" href="/css/main.min.0501cde787a831c36705f20a2589d2156b6b699bcf7c5b749bb4b5842d0bff5e.css" integrity="sha256-BQHN54eoMcNnBfIKJYnSFWtraZvPfFt0m7S1hC0L/14=" crossorigin="anonymous">


      <script src="/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js" integrity="sha256-I80MfYNyY7nq65buLZzPopadqj&#43;gD6HB/ocBqbhyUaE=" crossorigin="anonymous"></script>



</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Composability in functional and flow-based programming</h1>

  
  
  <time datetime="2021-02-12T16:24:00&#43;01:00">February 12, 2021</time>

  <!-- raw HTML omitted -->
<p>An area where I'm not so happy with some things I've seen in FP, is
composability.</p>
<p>In my view, a well designed system or langauge should make functions (or
other smallest unit of computation) more easily composable, not less.</p>
<p>What strikes me as one of the biggest elephants in the room regarding
FP, is that typical functions compose fantastically as long as you are
working with a single input argument, and a single output for each
function application, but as soon as you start taking multiple input
arguments and returned outputs though, you tend to end up with very
messy trees of function application. Even handy techniques such as
currying tend to get overly complex if you want to handle all the
possible downstream dataflow paths in a structured way.</p>
<p>I (think I) know that monads are supposed to be a highly general way of
addressing this problem, but it seems 99% of programmers (including me)
have a really really hard time properly understanding the concept well
enough that it would help make their code clearer, to them and others.</p>
<p>This is where I find the principles around network composability of
<a href="https://jpaulm.github.io/fbp/index.html" target="_blank" rel="noopener">Flow-based programming</a>
 (FBP)
shines so brightly.</p>
<p>It solves the composability problem in three basic ways:</p>
<ol>
<li>It gives each input and output its own identity, in the form of
<em>ports</em>.</li>
<li>It allows to define the data dependencies between these <em>ports</em>,
instead of between <em>functions</em>.</li>
<li>It allows the setup of these dependencies to happen at any place in
the program, which makes it easy to e.g. produce a list of all the
connections, as e.g. a simple list of (outport, inport) tuples.</li>
</ol>
<p>The second point above is significant, as it means data dependencies are
defined at the <em>level of data</em>, not <em>functions</em>.</p>
<p>Trying to define data dependencies by defining dependencies between
functions, is a major impedance mismatch in my books, and what is
causing the need for such complicated syntax in a lot of functional
programming.</p>
<p>Flow-based programs on the other hand, are so easy that they can be
simplified to two main parts:</p>
<ol>
<li>A list of processes (Somewhat the counterpart to functions in FP)</li>
<li>A list of connections between input- and output ports.</li>
</ol>
<p>These lists can either be code in a programming language embedded
framework or serialized text formats like JSON or XML. The simplicity
allows enormous flexibility.</p>
<p>With this background, I find that flow-based programming provides a
level of composability that in practice helps makes programs clear to a
much greater extent than functional programming.</p>

  


  </main>
  <footer>
    <p>Copyright &copy; 2024 Living Systems. All rights reserved.</p>

  </footer>
</body>
</html>
