<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Crystal: Go-like concurrency with easier syntax | Living Systems</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Crystal: Go-like concurrency with easier syntax</h1>

  <img src="selection_161-1.png">

  
  
  <time datetime="2020-09-05T15:36:00&#43;02:00">September 5, 2020</time>

  <p>I have been playing around a lot with concurrency in Go over the years,
resulting in libraries such as <a href="https://scipipe.org/">SciPipe</a>,
<a href="http://flowbase.org/">FlowBase</a> and
<a href="https://github.com/rdfio/rdf2smw/">rdf2smw</a>. My main motivation for
looking into Go has been the possibility to use it as a more performant,
scaleable and type-safe alternative to Python for data heavy scripting
tasks in bioinformatics and other fields I've been dabbling in.
Especially as it makes it so easy to write concurrent and parallel code
in it. Be warned that this context is surely giving me some biases.</p>
<p>I find the concurrency features of Go - with its lightweight goroutines
and channels - to be hard to beat in that it also provides true
parallelism by mapping the goroutines onto physical operating system
threads automatically in the background. Few if any other mainstream
languages does that. It lifts off a lot of concerns that you as a
developer don't need to deal with.</p>
<p>Still, the Go syntax has always felt rather complex. After 5+ years, I
have still not learned how to open up a file and reading from it line by
line, and need to check up the syntax on a site like
<a href="https://gobyexample.com">gobyexample.com</a>. This task also requires
importing two different libraries (os, and bufio), which you have to
remember.</p>
<p><img src="/site/assets/files/1111/selection_161.120x0-is.png" alt="">{.align_right
width=&ldquo;120&rdquo;}With this background, I found it interesting when a new
language on the block, <a href="https://crystal-lang.org/">Crystal</a>, <a href="https://crystal-lang.org/2019/09/06/parallelism-in-crystal.html">touts to
provide the same concurrency
features</a>,
still in a language with static typing and ahead-of-time compiling, with
a much more scriptlike and clean syntax.</p>
<p>In this post, I take a brief look at Crystal by implementing a pattern I
have been using a lot in Go: A simple pipeline, where one go-routine
does something like read from a file, feeding of the data to another
goroutine over a channel to do more work. I this post I will do this by
implementing an extremely simple pipeline that does just that, in both
of the languages, and then do some observations about the differences
between the languages. In more concrete terms, what the program does is:
let one go-routine read from a file line by line, and another one
calculate the frequency of G and C:s over all of A, T, G, Cs in a
DNA-file in the FASTA format.</p>
<p>You can find <a href="ftp://ftp.ensembl.org/pub/release-67/fasta/homo_sapiens/dna/Homo_sapiens.GRCh37.67.dna_rm.chromosome.Y.fa.gz">the (68MB) file I'm using
here</a>.</p>
<p>You can find both of the below code files <a href="https://github.com/samuell/experiments/tree/master/govscr">on GitHub
here</a>.</p>
<h3 id="go-implementation">Go implementation</h3>
<p>Here is the Go implementation:</p>
<pre><code>lang-go
package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    lineChan := make(chan string, 16)

    // ------------------------------------------------------------------------------
    // Loop over the input file in a separate fiber
    // ------------------------------------------------------------------------------
    go func() {
        defer close(lineChan)

        gcFile, err := os.Open(&quot;Homo_sapiens.GRCh37.67.dna_rm.chromosome.Y.fa&quot;)
        defer gcFile.Close()
        if err != nil {
            panic(err)
        }

        scan := bufio.NewScanner(gcFile)
        for scan.Scan() {
            line := scan.Text()
            lineChan &lt;- line
        }
    }()

    at := 0
    gc := 0

    for line := range lineChan {
        if line[0] == '&gt;' {
            continue
        }

        for _, chr := range line {
            switch chr {
            case 'A', 'T':
                at += 1
                continue
            case 'G', 'C':
                gc += 1
                continue
            }
        }
    }

    var gcFrac float64
    gcFrac = float64(gc) / float64(at+gc)
    fmt.Printf(&quot;GC fraction: %f\n&quot;, gcFrac)
}
</code></pre>
<p>Compile and run with e.g.:</p>
<pre><code>lang-bash
GOMAXPROCS=4; go build -o gcgo gc.go
./gcgo
</code></pre>
<h3 id="crystal-implementation">Crystal implementation</h3>
<p>... and here is the same functionality, implemented in Crystal:</p>
<pre><code>lang-crystal
lines_chan = Channel(String).new(16)

# ------------------------------------------------------------------------------
# Loop over the input file in a separate fiber (and thread, if you set the
# CRYSTAL_WORKERS count to something larger than 1), and send its output on a
# channel
# ------------------------------------------------------------------------------
spawn do
  gcfile = File.new(&quot;Homo_sapiens.GRCh37.67.dna_rm.chromosome.Y.fa&quot;)                                      
  gcfile.each_line() do |line|                                                                            
    lines_chan.send(line)                                                                                 
  end                                                                                                     
  gcfile.close 
ensure  
  lines_chan.close
end

# ------------------------------------------------------------------------------
# Loop over the lines on the channel in the main thread, and count GC fraction.
# ------------------------------------------------------------------------------
at = 0
gc = 0
while line = lines_chan.receive?
  if line.starts_with?('&gt;')
    next
  end
  line.each_byte() do |chr|
    case chr
    when 'A', 'T'
      at += 1
      next
    when 'G', 'C'
      gc += 1
      next
    end
  end
end

# ------------------------------------------------------------------------------
# Output results
# ------------------------------------------------------------------------------
gcfrac = gc / (gc + at)
puts &quot;GC fraction: #{gcfrac}&quot;
</code></pre>
<h3 id="heading"></h3>
<p>Note that to run the Crystal program with true multi-threading, you have
to send a flag: -Dpreview_mt, to use it.</p>
<p>Compile and run with e.g.:</p>
<pre><code>lang-bash
CRYSTAL_WORKERS=4; crystal build --release -Dpreview_mt -o gccr gc.cr
./gccr
</code></pre>
<h3 id="some-differences">Some differences</h3>
<p>We can note a few differences:</p>
<ul>
<li>The Crystal code is considerably shorter.</li>
<li>I find the Crystal code easier to read.</li>
<li>Crystal does not need to create a main()-function, but can include
code directly in the file, similar to Python and Ruby.</li>
<li>In Crystal you don't need to import multiple packages to open a
file, and to loop over it.</li>
<li>In Crystal, as seen in the code, we use
&quot;<a href="https://crystal-lang.org/reference/syntax_and_semantics/exception_handling.html#ensure">ensure</a>&quot;,
between any two &quot;begin/end&quot; clauses, in a similar way as Go:s
&quot;defer&quot;, to ensure something is done as the very last thing before
existing the function.</li>
<li>In my tests, the Go implementation has always outperformed the
Crystal one, so far. This might change with time of course.</li>
<li>Truly static binary deployments seem to not be fully supported in
Crystal just yet (see <a href="https://github.com/crystal-lang/crystal/issues/9285">Issue
#9285</a>).</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>I think it is a bit early to draw to hard conclusions between the two
langauges, as Crystal is so new, and this is just a very first test by
me. But I find it interesting to have two languages with a similar set
of concurrency primitives, to be able to compare various factors, as
well as approaches taken.</p>
<p>Crystal looks like a promising alternative to Go, for concurrency use
cases which allows writing in a much more script-like syntax. This could
potentially make it a really interesting language for scientific fields
such as bioinformatics, something that bioinformatics luminary <a href="https://twitter.com/lh3lh3">Heng
Li</a> <a href="https://lh3.github.io/2020/05/17/fast-high-level-programming-languages">has been blogging
about</a>
(and <a href="https://github.com/crystal-lang/crystal/issues/9285">pointed out a problematic area for
deployment</a>,
currently).</p>
<p>I'm still worried about whether Crystal will manage to provide the same
level of extremely portable, statically linked binaries though (EDIT:
<a href="https://crystal-lang.org/2020/02/02/alpine-based-docker-images.html">there's a workaround, using alpine
linux</a>),
and this might turn out to be a real dealbreaker. Also, with the
upcoming generics implementation in Go, some of the complexities of Go
might be possible to hide away for end-users of some libraries, by
providing high-level abstractions over typical complex tasks. One can of
course also wonder if Crystal will be able to reach the level of
popularity and size of ecosystem as Go, without a large industry backer
(maybe if they can leverage the large number of Ruby-developers looking
for a new compiled, fast language?).</p>
<p>It will be interesting to see what happens, as Crystal gets closer to
1.0, and Go soon gets generics into the language. What can be said for
sure, is that we will soon have more options, for writing concurrent,
performant code.</p>
<p><strong>Samuel</strong> (Twitter: <a href="https://twitter.com/smllmp">@smllmp</a>)</p>
<p><strong>Note:</strong> Some discussions on the post is/has been happening <a href="https://www.reddit.com/r/crystal_programming/comments/in80a9/crystal_concurrency_with_easier_syntax_than_go/">on
reddit</a>,
and <a href="https://forum.crystal-lang.org/t/blog-crystal-concurrency-with-easier-syntax-than-go/2505/4">on the crystal
forum</a>.</p>
<p><em><strong>Edit Sep 5, 2020, 19:45 CET:</strong> Update code to use &quot;ensure&quot;, after
<a href="https://forum.crystal-lang.org/t/blog-crystal-concurrency-with-easier-syntax-than-go/2505/2?u=shl">feedback from
@asterite</a>.</em><br>
<em><strong>Edit Sep 7, 2020, 08:35 CET:</strong> Clarify about how to compile optimized
Crystal code.</em><br>
<em><strong>Edit Sep 7, 2020, 08:57 CET:</strong> Add note about linking statically on
alpine linux.</em></p>

  


  </main>
  <footer>
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
