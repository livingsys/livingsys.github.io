<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>(E)BNF parser for parts of the Galaxy ToolConfig syntax with ANTLR | Living Systems</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>(E)BNF parser for parts of the Galaxy ToolConfig syntax with ANTLR</h1>

  <img src="screenshot-antlrworks_1_4_2.png">

  
  
  <time datetime="2011-07-28T09:46:00&#43;02:00">July 28, 2011</time>

  <p>As
<a href="http://saml.rilspace.com/fims-project-status-update-thinking-about-cli-wrapper-xml-formats">blogged</a>
earlier, I'm currently into parsing the syntax of some definitions for
the parameters and stuff of command line tools. As said in the linked
blog post, I was pondering whether to use the <a href="https://bitbucket.org/galaxy/galaxy-central/wiki/ToolConfigSyntax">Galaxy
Toolconfig</a>
format or the <a href="http://www.docbook.org/tdg/en/html/cmdsynopsis.html">DocBook CmdSynopsis
format</a>. It turned
out though Well, that cmdsynopsis lacks the option to specify a list of
valid choices, for a parameter, as is possible in the Galaxy ToolConfig
format (see
<a href="http://wiki.g2.bx.psu.edu/Admin/Tools/Tool%20Config%20Syntax#A.3Coptions.3E_tag_set">here</a>),
and thus can be used to generate drop-down lists in wizards etc. which
is basically what I want to do ... so, now I'm going with the Galaxy
format after all.</p>
<p>Enter the Galaxy format then. Look at an example code snippet:</p>
<pre><code>lang-xml
&lt;tool id=&quot;sam_to_bam&quot; name=&quot;SAM-to-BAM&quot; version=&quot;1.1.1&quot;&gt;
  &lt;description&gt;converts SAM format to BAM format&lt;/description&gt;
  &lt;requirements&gt;
    &lt;requirement type=&quot;package&quot;&gt;samtools&lt;/requirement&gt;
  &lt;/requirements&gt;
  &lt;command interpreter=&quot;python&quot;&gt;
    sam_to_bam.py
      --input1=$source.input1
      --dbkey=${input1.metadata.dbkey} 
      #if $source.index_source == &quot;history&quot;:
        --ref_file=$source.ref_file
      #else
        --ref_file=&quot;None&quot;
      #end if
      --output1=$output1
      --index_dir=${GALAXY_DATA_INDEX_DIR}
  &lt;/command&gt;
  &lt;inputs&gt;
    &lt;conditional name=&quot;source&quot;&gt;
      &lt;param name=&quot;index_source&quot; type=&quot;select&quot; label=&quot;Choose the source for the reference list&quot;&gt;
        &lt;option value=&quot;cached&quot;&gt;Locally cached&lt;/option&gt;
        &lt;option value=&quot;history&quot;&gt;History&lt;/option&gt;
      &lt;/param&gt;
      &lt;when value=&quot;cached&quot;&gt;
      ... cont ...
</code></pre>
<p>Here I've got some challenges. XML parsing is easy, even in Java (I use
the Java XPath libs for that). But look inside the <code>&lt;command&gt;</code> tag ...
that's some really non-xml stuff, no? (it is instructions for a python
based template library, used in galaxy). I have to parse this though, in
order to replicate the logic of it ... so what to do? ... well, I
turned to the <a href="http://www.antlr.org/">ANTLR Parser Generator</a>.</p>
<h3 id="toc0">ANTLRWorks works nicely out of the box</h3>
<p>I heard a lot of good things about <a href="http://www.antlr.org/">ANTLR</a>, like
that it is more easily debugged than typical BNF parsers etc, so the
choice wasn't that hard. I tried the ANTLR for Eclipse, but though it
looks nice, it that was quite buggy, and I couldnt get it to work
properly in neither Eclipse 3.5 or 3.6. So, finally I went with the easy
option and developed my EBNF grammar in
<a href="http://www.antlr.org/works/index.html">ANTLRWorks</a>, which is an
integrated Java App, with the correct ANTLR lib already installed etc.
Turned out to work really good!</p>
<p>The grammar I came up with so far (only for the syntax inside the
&lt;command&gt; tag so far, though!) is <a href="https://github.com/samuell/galaxy-toolconfig-bnf/blob/master/GalaxyToolConfig.g">available on
GitHub</a>
... and below (in condensed syntax to save some space), for you
convenience :)</p>
<pre><code>lang-bnf
grammar GalaxyToolConfig;
options {output=AST;}
 
command    : binary (ifstatement param+ (ELSE param+)? ENDIF | param)*;
binary     : WORD;
ifstatement 
        : IF (STRING|VARIABLE) EQTEST (STRING|VARIABLE) COLON;
param   : DBLDASH WORD* EQ (VARIABLE|STRING);
WORD    : ('a'..'z'|'A'..'Z')('a'..'z'|'A'..'Z'|'.'|'_'|'0'..'9')*;
VARIABLE 
        : '$'('{')?WORD('}')?;
STRING  : '&quot;'('a'..'z'|'A'..'Z')+'&quot;';
IF      : '#if';
ELSE    : '#else';
ENDIF   : '#end if';
EQ      : '=';
EQTEST  : '==';
DBLDASH : '--';
COLON   : ':';
WS      : (' '|'\t'|'\r'|'\n') {$channel=HIDDEN;};
</code></pre>
<p>Suggestions for improvements? :) ... Then go ahead and mail me ...
samuel dot lampa at gmail dot com)</p>
<p>Also, see a little screenshot from ANTLRWorks below:</p>
<p><a href="/site/assets/files/1102/screenshot-antlrworks_1_4_2.png"><img src="/site/assets/files/1102/screenshot-antlrworks_1_4_2.871x0-is.png" alt="">{width=&ldquo;871&rdquo;}</a></p>
<p><em>As you can see in the screenshot, the different parts have correctly
been identified as &quot;param&quot;, &quot;if statement&quot; and so forth. You can se
also how I can click in the test syntax, to see where in the parse tree
that actual part appears.</em></p>
<p>When done, I just exported the resulting parser code in ANTLRWorks with
<em>&quot;Generate &gt; Generate Code&quot;</em>, copied the code from the &quot;output&quot;
folder into my Eclipse project, added the antlr-3.3 jar into the build
path of it, and then ran the __Test__.java file that comes with the
output.</p>
<p>I wanted to do a little more parsing in my test though, so I ended up
with this little test code:</p>
<pre><code>lang-java
package net.bioclipse.uppmax.galaxytoolconfigparser;
import org.antlr.grammar.v3.*;
import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CharStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.TokenStream;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.DOTTreeGenerator;
import org.antlr.runtime.tree.Tree;
import org.antlr.runtime.tree.TreeAdaptor;
import org.antlr.stringtemplate.StringTemplate;
 
public class ParseTest {
    // Generated stuff from ANTLR, which I can use to recognize token types   
    public static final int EOF=-1;
    public static final int ELSE=4;
    public static final int ENDIF=5;
    public static final int WORD=6;
    public static final int IF=7;
    public static final int STRING=8;
    public static final int VARIABLE=9;
    public static final int EQTEST=10;
    public static final int COLON=11;
    public static final int DBLDASH=12;
    public static final int EQ=13;
    public static final int WS=14;
 
    public static void main(String[] args) throws RecognitionException {
        String testString = &quot;    sam_to_bam.py&quot; 
                + &quot;      --input1=$source.input1\n&quot;
                + &quot;      --dbkey=${input1.metadata.dbkey}\n&quot;
                + &quot;      #if $source.index_source == \&quot;history\&quot;:\n&quot;
                + &quot;        --ref_file=$source.ref_file\n&quot; 
                + &quot;      #else\n&quot;
                + &quot;        --ref_file=\&quot;None\&quot;\n&quot; 
                + &quot;      #end if\n&quot;
                + &quot;      --output1=$output1\n&quot;
                + &quot;      --index_dir=${GALAXY_DATA_INDEX_DIR}\n&quot;; 
        CharStream charStream = new ANTLRStringStream(testString);
        GalaxyToolConfigLexer lexer = new GalaxyToolConfigLexer(charStream);
        TokenStream tokenStream = new CommonTokenStream(lexer);
        GalaxyToolConfigParser parser = new GalaxyToolConfigParser(tokenStream, null);
 
        System.out.println(&quot;Starting to parse ...&quot;);
        // GalaxyToolConfigParser.command_return command = parser.command();
        CommonTree tree = (CommonTree)parser.command().getTree();
        System.out.println(&quot;Done parsing ...&quot;);
 
        int i = 0;
        while (i&lt;tree.getChildCount()) {
            Tree subTree = tree.getChild(i);
            System.out.println(&quot;Tree child: &quot; + subTree.getText() + &quot;, (Token type: &quot; + subTree.getType() + &quot;)&quot;);
            i++;
        }
 
        // Generate DOT Syntax tree
        //DOTTreeGenerator gen = new DOTTreeGenerator();
        //StringTemplate st = gen.toDOT(tree);
        //System.out.println(&quot;Tree: \n&quot; + st);
 
        System.out.println(&quot;Done!&quot;);
    }
}
</code></pre>
<p>... generating this output:</p>
<pre><code>lang-log
Starting ...
Done executing command ...
Subtree text: sam_to_bam.py, (Token type: 6)
Subtree text: --, (Token type: 12)
Subtree text: input1, (Token type: 6)
Subtree text: =, (Token type: 13)
Subtree text: $source.input1, (Token type: 9)
Subtree text: --, (Token type: 12)
Subtree text: dbkey, (Token type: 6)
Subtree text: =, (Token type: 13)
Subtree text: ${input1.metadata.dbkey}, (Token type: 9)
Subtree text: #if, (Token type: 7)
Subtree text: $source.index_source, (Token type: 9)
Subtree text: ==, (Token type: 10)
Subtree text: &quot;history&quot;, (Token type: 8)
Subtree text: :, (Token type: 11)
Subtree text: --, (Token type: 12)
Subtree text: ref_file, (Token type: 6)
Subtree text: =, (Token type: 13)
Subtree text: $source.ref_file, (Token type: 9)
Subtree text: #else, (Token type: 4)
Subtree text: --, (Token type: 12)
Subtree text: ref_file, (Token type: 6)
Subtree text: =, (Token type: 13)
Subtree text: &quot;None&quot;, (Token type: 8)
Subtree text: #end if, (Token type: 5)
Subtree text: --, (Token type: 12)
Subtree text: output1, (Token type: 6)
Subtree text: =, (Token type: 13)
Subtree text: $output1, (Token type: 9)
Subtree text: --, (Token type: 12)
Subtree text: index_dir, (Token type: 6)
Subtree text: =, (Token type: 13)
Subtree text: ${GALAXY_DATA_INDEX_DIR}, (Token type: 9)
Done!
</code></pre>
<p>... seemingly I have the stuff I need, for doing some logic parsing
now! :)</p>
<h3 id="toc1">Some words about BNF</h3>
<p>ANTLR is an (E)BNF parser generator. I had heard a little about BNF
before, and was more or less scared off from the topic, thinking it
looked too advanced, but really, I found it isn't that hard at all!</p>
<p>It strikes me that BNF is quite much <em>RegEx</em> but with functions added,
which allows for recursive pattern matching, which you'll need for
anything more advanced, such as nested braces/xml tags etc ... but as
you can see in the example above also, much of the pattern matching
syntax actually has big similarities to RegEx.</p>
<p>In terms of tutorials, for the (E)BNF/ANTLR combo at least, I'd highly
recommend <a href="http://vimeo.com/groups/29150/videos/8137747">this set of screencasts on using ANTLR in
Eclipse</a>. Though I didn't
use the Eclipse version, these screencasts quickly give you an idea of
how it all works ... I watched at least a bunch of them, and I'm happy
I did.</p>
<h3 id="toc2">Links</h3>
<ul>
<li>The EBNF I came up with so far is available on
<a href="https://github.com/samuell/galaxy-toolconfig-bnf/blob/master/GalaxyToolConfig.g">GitHub</a></li>
<li>The generated parser <a href="https://github.com/bioclipse/bioclipse.uppmax/tree/master/plugins/net.bioclipse.uppmax/src/net/bioclipse/uppmax/galaxytoolconfigparser">is,
too</a>
(Though in another github project)</li>
</ul>

  


  </main>
  <footer>
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
