<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>FBP inspired data flow syntax: The missing piece for the success of functional programming? | Living Systems</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>FBP inspired data flow syntax: The missing piece for the success of functional programming?</h1>

  <img src="selection_288.png">

  
  
  <time datetime="2015-07-16T17:13:00&#43;02:00">July 16, 2015</time>

  <p><img src="/site/assets/files/1055/selection_288.667x0-is.png" alt=""></p>
<p>Often when I suggest people have a look at <a href="http://www.jpaulmorrison.com/fbp/">Flow-based
Programming</a> (FBP) or <a href="https://en.wikipedia.org/wiki/Dataflow">Data
Flow</a> for one reason or another,
people are often put off by the strong connection between these concepts
and graphical programming. That is, the idea that programs will be
easier to understand if expressed and developed in a visual notation.</p>
<p>This is unfortunate, since I think this is in no way the core benefit of
FBP or Data Flow, although it is a nice side-effect for those who prefer
it. For example, I personally mostly prefer working with text over a
graphical notation, for productivity reasons.</p>
<h3 id="the-purpose-of-this-post">The purpose of this post</h3>
<p>There are so many inherent benefits with the data flow / flow-based
programming paradigm that it is hard to know where to start. Implicit
pipeline parallelism, exceptional composability, testability,
inspectability, code re-use are just a few examples. In this post
though, I thought to illustrate how I think even just a subset of its
ideas - the syntax - could potentially greatly benefit the design of
e.g. functional programming API:s.</p>
<h3 id="the-limitations-of-functional-callreturn-semantics">The limitations of functional call/return semantics</h3>
<p>To make a long story really short, I think that as long as functional
programming (FP) languages don't go beyond the call/return semantics
[Edit: True, most FP language have gone beyond this] or chained
lazy-evaluating functions [Edit: this still seems to be state of the
art in many FP langs] for creating streaming processing networks, it
will not succeed at improving the situation for software engineering in
general in any revolutionary way.</p>
<p>I see the following limitations with these:</p>
<ol>
<li>In the case of the call/return semantics, dependent upstream
functions are often hard-coded inside the &quot;meat&quot; code of the
functions, creating hard-coded depencies, detrimental to the
composability of programs.</li>
<li>&quot;API specialities&quot; like multiple return values, are not easy to
route into different downstream paths, but typically has to be
received and treated by every function that calls a multi-returnval
function, creating even more intricate dependencies between
&quot;API:s&quot; of calling and returning functions. This means that you
can't easily swap a function returning a single value, with one
that returns more than one, even if the second return value is not
really used, or is supposed to be used elsewhere.</li>
</ol>
<p>Number <strong>2.</strong> above seems to be the one that is still the most ubiqutuos
in FP langs today, while number <strong>1.</strong> is largely solved by various
constructs such as .map(), .filter() etc, taking anonymous functions as
one of its parameters, and allowing to build up a chain of processing
steps by padding such map/filter/etc calls on each other.</p>
<p>Anyways, let's look at how lazy-evaluated streaming operations are
implemented in a widely known language such as python (not really a
functional language, but featuring constructs commonly referred to as
&quot;functional&quot;). More exactly, let's look at how a bunch of
lazy-evaluating python generator objects are chained together to form a
sequential, lazy-evaluated, processing pipeline:</p>
<pre><code>lang-python
# Create a generator object using generator-comprehension syntax
gen_his = ('hi for the %d:th time!' % i for i in xrange(10))

# Create a generator that upper-cases the strings lazy-evaluatedly:
gen_uc_his = (s.upper() for s in gen_his)

# Let's print this:
for s in gen_uc_his:
  print(s)
</code></pre>
<p>This looks all fine for a simple linear pipeline like this: [String
producer] -&gt; [String uppercaser] -&gt; [String printer]. But what if
we want, say for example, to instead of the uppercaser, split the string
in two halves, and send the first part to a lower-caser, and the rest to
an upper-caser (sorry for the exceedingly synthetic example)? How do you
express that with generator functions? You would have to call the same
generator twice, something like:</p>
<pre><code>lang-python
# Create a generator object using generator-comprehension syntax:
gen_his = ('hi for the %d:th time!' % i for i in xrange(10))

# Create a generator that returns the first and second half of each string:
gen_splitted_his = ((s[len(s)//2:], s[:len(s)//2]) for s in gen_his)

# Create a generator that lower-cases the left half of the strings:
gen_lc_his = (left.lower() for left, right in gen_splitted_his)
# Create a generator that upper-cases the left right of the strings:
gen_uc_his = (right.upper() for left, right in gen_splitted_his)

# Printing omitted here for brevity.
</code></pre>
<p>But, this will produce an error, since running a generator function
twice is not allowed, and this would not re-use the same items in memory
anyway, which is kind of the main point with stream processing. Also, do
you notice how we need to unpack the left and right parts of the
strings, in the downstream generators that use gen_splitted_his - thus
creating a dependency on its return signature!</p>
<p>And this is only an extremely simple example. Imagine solving these kind
of intricacies in a larger networks of inputs and outputs needing to
&quot;flow&quot; through processes!</p>
<p>Now, in the above example, we had hard-coded the dependencies on
upstream generator functions. We could go a little more
&quot;loose-coupled&quot; by using dependency injection, and taking the upstream
generator as an argument to a function that returning a generator (which
is defined by using the &quot;yield&quot; keyword instead of &quot;return&quot;, in the
normal python function definition syntax):</p>
<pre><code>lang-python
# Create a generator object using generator-comprehension syntax:
gen_his = ('hi for the %d:th time!' % i for i in xrange(10))

# Create a generator that returns the first and second half of each string:
def gen_splitted_his(upstream_generator):
  for s in upstream_generator:
    yield (s[len(s)//2:], s[:len(s)//2])

# Create a generator that lower-cases the left half of the strings:
def gen_lc_his(upstream_generator):
  for left, right in upstream_generator:
    yield left.lower()

# Create a generator that upper-cases the left right of the strings:
def gen_uc_his(upstream_generator):
  for left, right in upstream_generator:
    yield right.upper()

# Chain the generators together using dependency injection
splitted_his = gen_splitted_his(gen_his)
lc_his = gen_lc_his(splitted_his)
uc_his = gen_uc_his(splitted_his)

# Now, we would loop over lc_his and uc_his separately, to print
</code></pre>
<p>So, using dependency injection, we have removed the hard-coded
dependency between the generators. But we still have a kind of &quot;API&quot;
or &quot;signature&quot; dependency between the gen_splitted_his and
gen_{us,lc}_his, in that the latter require to receive a generator
that yields tuples of two strings. Thus, the lower-case and upper-case
generator objects are not really generic.</p>
<h3 id="fbp-inspired-network-syntax-to-the-resque">FBP inspired network syntax to the resque</h3>
<p>In the flow-based programming way of defining stream processing
networks, none of the above is a problem, since dependencies are <em>not
defined between functions</em>, but <em>between inputs and outputs of functions
[1]</em>, and actually even more generally: <em>between inputs, outputs and
channel objects</em> which goes from from the output of one task to the
input of another one.</p>
<p>There are various ways to define the network declaratively (See the
<a href="https://github.com/trustmaster/goflow">GoFlow code examples</a> for one
recent example). I have came to like a certain style that is as similar
as possible to normal procedural code, by using single-assignments to
connect outputs of one process (or &quot;function&quot;), to other processes.</p>
<p>I haven't yet implemented anything like that in pure python (don't
even know how easy it would be ... maybe possible using co-routines),
but have <a href="http://blog.gopheracademy.com/composable-pipelines-pattern">done it in
Go</a>, and for
the python-based <a href="https://github.com/spotify/luigi#readme">Luigi</a>
workflow tool by Spotify (<a href="https://github.com/samuell/sciluigi">See our SciLuigi library for code
examples</a>). I propose checking
those two links for concrete real-world code examples, but just to
illustrate how to the above toy code example could look like in vanilla
python, with a little imagination:</p>
<pre><code>lang-python
# Create an FBP process that generates Hi's:
class GenerateHis(FBPProcess):
  # Define in/out-ports
  his = OutPort()
  # Define main routine
  def run(self):
    for i in range(10):
      self.his.send('hi for the %d:th time!' % i)

# Create an FBP process that splits strings into two halves:
def SplitStrings(FBPProcess):
  # Define in/out-ports
  input = InPort()
  left_part = OutPort()
  right_part = OutPort()
  # Define main routine
  def run(self):
    for s in self.input.receive():
      self.left_part.send(s[len(s)//2:])
      self.right_part.send(s[:len(s)//2])

# Create a generator that lower-cases strings:
class LowercaseStrings(FBPProcess):
  # Define in/out-ports
  input = InPort()
  lowercased = OutPort()
  # Define main routine
  def run(self):
    for s in self.input_string.receive():
      self.lowercased.send(s.lower())

# Create a generator that lower-cases strings:
class UppercaseStrings(FBPProcess):
  # Define in/out-ports
  input = InPort()
  uppercased = OutPort()
  # Define main routine
  def run(self):
    for s in self.input_string.receive():
      self.uppercased.send(s.upper())

# Initiate ... 
hi_generator = GenerateHis()
splitter = SplitStrings()
uppercaser = UppercaseStrings()
lowercaser = LowercaseStrings()

# ... and chain the FBP processes together, using single-assignment syntax:
splitter.input = hi_generator.his
lowercaser.input = splitter.left_part
uppercaser.input = splitter.right_part
# NOTE: The above three lines are kind of the gist of this whole post!! :)

# Loop over the lower and upper-cased strings separately and print:
for s in lowercaser.lowercased.receive():
  print(s)
for s in uppercaser.uppercased.receive():
  print(s)

# (Depending on implementation, the components might be added to a network
#  component too, that drives the execution of all the processes).
</code></pre>
<p>So, do you see how now we have completely generic processes for
lower-casing and upper-casing, without any dependencies on the number of
outputs yielded by the upstream process? ... and how the reason for
this was that we split out the wiring of outputs-&gt;inputs to be done
<em>outside</em> of the processes themselves (the lower.input =
split.left_part part of the code example above).</p>
<p><em><strong>[EDIT] Note:</strong> This is not a working example, since that would
require some kind of concurrent features that is not available in
vanilla python (it seems something like stackless python is required).
Any way, for the sake of proof-of-concept, <a href="http://bionics.it/posts/how-i-would-like-to-write-golang">I have implemented this same
code in Go, blogged about in this follow-up
post</a> (Where
the ideas behind that syntax is explained in detail in my <a href="http://blog.gopheracademy.com/composable-pipelines-pattern">blog post
outlining how to write using this syntax in Go, on
GopherAcademy</a>).</em></p>
<h3 id="concluding-remarks"><strong>Concluding remarks</strong></h3>
<p>So, in conclusion, it seems like the flow-based programming inspired
syntax presented above, does away with two of the main problems in
normal call/return-style functional syntax: Hard-coded dependencies
between functions, and hard-coded dependencies between input/output
signature of functions.</p>
<p>It does this by leveraging the FBP-inspired ideas of <em>separate network
definition</em> (outside of the functions and processes themselves), and
<em>named, separate inputs and outputs.</em> As is also shown in the toy code
example above, as well as the linked real-world examples, the syntax for
connecting processes in this way, can be made very similar to normal
procedural code, by using single-assignment to connect outports of one
process to the inports of another.</p>
<p>Finally, I should say I very much welcome tips/links if I have missed
some solution to the problems above in some functional programming
language, as well as constructive feedback in general!</p>
<h3 id="notes-in-text">Notes in text</h3>
<p>[1] Note how this is very much related to a <a href="http://bionics.it/posts/workflows-dataflow-not-task-deps">previous post of mine,
touching on the same issue for workflow
tools</a>.</p>
<h3 id="general-notes">General notes</h3>
<p><em><strong>Note I:</strong> See <a href="https://twitter.com/peteramstutz/status/621773806948888577">this discussion on
twitter</a>,
about combining data from multiple ports.<br>
<strong>Note II:</strong> See also <a href="https://news.ycombinator.com/item?id=9899493">discussion on Hacker
News</a>.</em><br>
<em><strong>Note III:</strong> See also <a href="https://www.reddit.com/r/programming/comments/3djimr/fbp_inspired_data_flow_syntax_the_missing_piece/">discussion on
Reddit</a>.</em><br>
<em><strong>Note IV:</strong> See especially <a href="https://www.reddit.com/r/programming/comments/3djimr/fbp_inspired_data_flow_syntax_the_missing_piece/ct60oqc">this excellent
comment</a>
in the <a href="https://www.reddit.com/r/programming/comments/3djimr/fbp_inspired_data_flow_syntax_the_missing_piece/">Reddit
thread</a>.</em><br>
<em><strong>Note V:</strong> Have added link to a working example in Go(lang), of the
final non-working python example code. See <a href="http://bionics.it/posts/how-i-would-like-to-write-golang">this follow-up post with the
Go example</a>!</em></p>

  


  </main>
  <footer>
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
