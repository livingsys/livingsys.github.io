<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Flow-based programming and Erlang style message passing - A Biology-inspired idea of how they fit together | Living Systems</title>

      <link rel="stylesheet" href="/css/main.min.0a062e1fd1fd023b5bddc54370019169be4022da587623f7783189ac23d60d39.css" integrity="sha256-CgYuH9H9Ajtb3cVDcAGRab5AItpYdiP3eDGJrCPWDTk=" crossorigin="anonymous">


      <script src="/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js" integrity="sha256-I80MfYNyY7nq65buLZzPopadqj&#43;gD6HB/ocBqbhyUaE=" crossorigin="anonymous"></script>



</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Flow-based programming and Erlang style message passing - A Biology-inspired idea of how they fit together</h1>

  
  
  <time datetime="2015-06-13T14:25:00&#43;02:00">June 13, 2015</time>

  <p><strong>I think Erlang/Elixir fits great as control plane or
service-to-service messaging layer for distributing services built with
flow-based programming</strong></p>
<p><p class="image">
    <img src="erlang_logo.png" alt="Erlang logo"  class="align_right" />
</p>
Just
back from a one day visit to <a href="http://www.erlang-factory.com/euc2015">Erlang User
Conference</a>. I find the
<a href="http://www.erlang.org/">Erlang</a> virtual machine fascinating. And with
the new <a href="http://elixir-lang.org/">Elixir language</a> built on top of it to
fix some of the pain points with <em>Erlang the language</em>, the eco-system
has got even more interesting.</p>
<p>What I find exciting about Erlang/Elixir and its virtual machine, is its
ability to utilize multiple CPU:s on computers, and doing this across
multiple computers, in what is commonly referred to as &quot;distributed
computing&quot;. <a href="fbp_general_interactive_application.png"><p class="image">
    <img src="fbp_general_interactive_application.png" alt="Flow-based programming example. Image from
http://jpaulmorrison.com/fbp/examples.html"  class="align_right" />
</p>
</a>
But then, <a href="http://www.jpaulmorrison.com/fbp/">Flow-based programming</a> (FBP) are
often pitched for basically the same purposes: good at running things in
parallel in general. So, how do these two paradigms compare?</p>
<h3 id="flow-based-programming-and-erlangelixir-seems-like-a-great-fit">Flow-based programming and Erlang/Elixir seems like a great fit?</h3>
<p>It is hard not to think that the flow-based programming paradigm, with
its multiple &quot;black box&quot; processes talking to each other over channels
and the Erlang message-passing model of highly isolated processes
sending messages to the mail boxes of other processes, would have a lot
of overlap in functionality. One would think the architecture of one of
the systems should be easy enough to implement in the other system.
There is actually at least one such project trying to implement FBP in
Elixir, by <a href="http://twitter.com/petercmarks">Peter C Marks</a>, the
<a href="http://www.elixirfbp.org/">elixirfbp</a> project (worth checking out!).</p>
<p>Looking closer, it turns out there are a number of challenges though.
E.g. back-pressure is not as easily supported implicitly in
Erlang/Elixir as in FBP languages where the bounded-buffer channels
provide implicit back-pressure by blocking the sends on the out-port
they are connected to when the buffer is full. And, implementing
something like the channels with bounded buffers of FBP in Elixir would
require another process for the channel, which would mean another
copying step, which is bad for performance.</p>
<p>There is also a bit of different behavior in how processes are
connected. While in FBP processes are explicitly connected with channels
between the named in-/out-ports of the processes, in Erlang/Elixir on
the other hand, processes send messages to a single mailbox in each
recipient process, and any filtering for multiple further routing is
happening in code, applied on this single mailbox. Thus, to implement in
a general way something like FBP-style in-ports and out-ports would
probably require creating even further specialized Erlang/Elixir
processes. Maybe you need one for each in-port/out-port, which would
mean even more data copying.</p>
<p><em><strong>These architectural differences were by the way something that was
touched upon in highly recommended a <a href="http://www.erlang-factory.com/euc2014/paul-butcher">talk by Paul Butcher at
EUC2014</a> last year
(See
<a href="http://www.erlang-factory.com/static/upload/media/1403178373396314paulbutchereuc2014.pdf">Slides</a>
and <a href="https://vimeo.com/102707745">Video</a>)</strong></em></p>
<p>One thing I'm still wondering about though, is whether the overhead of
this copying might not be such a big problem since you now will have
pipeline parallelism in Elixir, as Jos√©
<a href="http://www.erlang-factory.com/euc2015/jose-valim">presented</a>:</p>
<p><p class="image">
    <img src="elixir-pipeline-parallellism-crop.jpg" alt=""  />
</p>
</p>
<p>(See original
<a href="https://twitter.com/smllmp/status/609306287516610560">tweet</a>, and the
<a href="http://www.erlang-factory.com/euc2015/jose-valim">info page for the
talk</a> where slides and
video will show up)</p>
<h3 id="further-differences-between-the-paradigms">Further differences between the paradigms</h3>
<p>Anyways, there is a whole other set of aspects that make FBP and the
Erlang VM quite different though.</p>
<p>For example, despite the great work on the <a href="https://www.it.uu.se/research/group/hipe/">HiPE
VM</a> for compiled Erlang code,
and the work going on with JIT-compilation for Erlang (Mentioned in the
<a href="http://www.erlang-factory.com/euc2015/kenneth-lundin">&quot;News from the OTP team&quot;
session</a> at the
EUC2015), Erlang is in it's current state kind of slow for many types
of computations. It is scalable yes, but slow. For example I tried some
simple string processing algorithm in Elixir recently, which I've used
to <a href="http://saml.rilspace.org/moar-languagez-gc-content-in-python-d-fpc-c-and-c">benchmark a bunch of other languages
before</a>,
and found that Elixir was something like 3 times slower than
un-optimized, vanilla python for the same task, which is itself around
2-3 times slower than most compiled languages for the same task (I
sincerely hope I did some serious mistake to make it this slow)
<strong>[EDIT: This slowness turns out to be disputed! See Note V in the top
of the page]</strong>.</p>
<p>On the other hand, the Erlang VM is truly outstanding when it comes to
other aspects that are crucial for distributed (as in multi-compute
nodes) computing, such as process isolation, fault-tolerance,
inspectability, hot code-reloading, and much more.</p>
<h3 id="erlang-great-as-control-plane">Erlang great as control plane</h3>
<p>The above means that you will typically want to use Erlang for things
like the control plane of your distributed system, while the actual
computation part will be optimally implemented in something faster, such
as C, if your computation demands are large while cost/energy efficiency
is also of importance.</p>
<p>Combining Erlang with a faster language for the actual processing, is
actually exactly what is done at the company where Erlang was born in
the first place, Ericsson. At the <a href="http://www.erlang-factory.com/euc2015/anders-danne">&quot;Embedded Erlang&quot; talk on
EUC2015</a>, Anders
Danne of Ericsson revealed details about an interesting project which
just resulted in a new product (a base station), where Erlang was the
control plane while the real crunching code was implemented in/with C
and FPGA.</p>
<h3 id="what-can-we-learn-from-the-most-advanced-information-system-we-know-of---the-human-cell">What can we learn from the most advanced information system we know of - the human cell?</h3>
<p>This leads up to my idea for how I think these two paradigms best fit
together. But just to even further strengthen the case, let me also take
an example from the amazing information systems implemented in the human
body.</p>
<p>Biology is full of information systems at different scales, but two of
these that strike me as excellent examples of the items at play in this
post are <strong>a)</strong> the DNA-to-RNA-to-Protein information processing chain
commonly known as &quot;the central dogma&quot;, and <strong>b)</strong>, cell-to-cell
signalling.</p>
<h4 id="the-dna-rna-protein-processing-chain">The DNA-&gt;RNA-&gt;Protein processing chain</h4>
<p>The DNA-&gt;RNA-&gt;Protein processing chain is a very low-level intricate
chain of information processing that happens partly in the cell nucleus,
partly in the space outside the nucleus (but still within he cell wall).
It requires exceptional performance since there are large amounts of
information that need to be poured out in a very short time, as this
process might kick in when the concentration of certain molecular
machines known as enzymes need to quickly increase, for example when you
have just eaten and enzymes for breaking down a certain food product
need to be processed by specialized enzymes.</p>
<p><strong>So, how is this implemented in the human cell?</strong></p>
<p>Well, I think my words will fall short of describing this amazing
process, so let's watch a little 3 minute animation instead:</p>
<p>Do you see how the molecular machines are producing long &quot;streams&quot; of
information (e.g. an mRNA strand), while continuously reading another
&quot;stream&quot; of information (e.g. a DNA strand), or the same thing for
Protein-&quot;strands&quot; and mRNA-strands.</p>
<p>I don't know about you, but to me, this looks a lot like flow-based
programming! - a highly optimized process where the physical proximity
of the molecular letters stitched together into a &quot;strand&quot; or
&quot;stream&quot; of information, that is processed in &quot;streaming mode&quot; by a
molecular machine into another stream of information.</p>
<h4 id="cell-to-cell-signalling-for-robust-signalling-outside-the-safe-and-predictable-nature-within-the-cell-walls">Cell-to-cell signalling for robust signalling outside the safe and predictable nature within the cell walls</h4>
<p>Cell-to-cell signalling, in contrast to the DNA-&gt;RNA-&gt;Protein
processing chain, does involve less amount of information (but could
still be <em>at least</em> as significant), since being a very high-level form
of communication, it is heavily dependent on shared context between
cells. That is, both the sending and receiving cell share so much common
knowledge that they will immediately be able to interpret the received
message correctly, even if the actual message contains very little
amount of (shannon) information.</p>
<p>Compare this to e.g. a group of SWAT soldiers who have made up detailed
plan for an attack, and then just are positioning themselves, and awaits
a simple &quot;Go!&quot; message via their radios. The &quot;Go!&quot; message will
contain hardly more than one or a few bits of information, measured in
shannon information metrics, but due to the high amount of shared
context information among the soldiers, it will be a highly significant
message, that will trigger a very detailed plan, at precisely the right
time.</p>
<p>Thus, the computational requirements here are less demanding. On the
other hand there are other requirements, such as robustness to failure,
since when these signalling molecules leave the cellular walls, the
environment will be all the less reliable and predictable.</p>
<p><strong>So, how is this implemented in the biological systems?</strong></p>
<p>Here again, let's look at an animation of an example of the process
rather than me trying to explain the steps in detail:</p>
<p>The video shows one specific cell signaling &quot;pathway&quot; as they are
called, but the same basic principles hold for many other &quot;pathways&quot;:
A signaling molecule is excreted from one cell, and then interacts with
a receptor on the surface of another cell, that actually spans the cell
wall, and triggers a chain of reaction on the inside of the
&quot;recipient&quot; cell.</p>
<p>Things like robustness are here handled especially, by executing an
excess of signaling molecules, more than will probably reach receptors
of other cells.</p>
<h3 id="what-can-we-learn-from-this">What can we learn from this?</h3>
<p>So what can we learn from the two biological information processing
examples above?</p>
<p>Well, my idea with including these examples is that they are two very
different solutions to information processing problems at very different
scales in the cell: The DNA-&gt;RNA-&gt;Protein processing chain does the
heavy lifting of translating high amounts of structural information
about the molecular machines to be produced, while various cell-to-cell
signaling pathways are more a kind of &quot;alerting&quot; systems for cells to
notify each other of various state changes in behavior needed for nearby
cells, due to e.g. something happening in the close-by area.</p>
<p>Personally, I think there is an interesting match between these two
information systems and the two information processing paradigms
discussed in this article: Erlang style message passing and Flow-based
processing. I see the match like this:</p>
<ul>
<li>DNA-&gt;RNA-&gt;Protein processing chain &lt;--&gt; Flow-based programming.</li>
<li>Cell-to-cell signaling &lt;--&gt; Erlang style message passing.</li>
</ul>
<p>One of these - the cell-to-cell signaling, is aimed at synchronizing
state <em><strong>between</strong></em> nearby cells, while the other, DNA-&gt;RNA-&gt;Protein
chain, is for the heavy lifting of processing large amounts of data
<em><strong>inside</strong></em> each cell.</p>
<p>The first one is a very &quot;loose&quot; process, in that signaling molecules
are released in excess, but on &quot;chance&quot;, and will eventually reach
receptors on the surfaces of nearby cells, and initiate some kind of
response. This I would compare with the situation in TCP/IP networks,
where predictability is not really the same as within the safe &quot;walls&quot;
of the CPU. This would be where the robustness-increasing features of
Erlang really shines.</p>
<p>The DNA-&gt;RNA-&gt;Protein processing chain on the other hand, with its
very strict requirements on performance, has a very tight (even
physical) coupling between the input data, the processing machinery, and
the output data, and the placement of data into a &quot;stream&quot; (&quot;strand&quot;
in biological terms) means that while pulling an information item /
nucleotide through the processing machinery, the next item to process
will automatically be pulled in. This would be where the
stream-processing nature of Flow-based programming really shines.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Based on this study of biological information systems, I would suggest
that:</p>
<ul>
<li><strong>Flow-based programming</strong> is very well suited for high performance
heavy lifting within one micro-service (or some other similar unit
comparable to a biological cell), while:</li>
<li><strong>Erlang-style message passing</strong> is the perfect paradigm for
communication between such services.</li>
</ul>
<p>So, maybe, just like Ericsson is using Erlang as a control plane for C
and FPGA code, maybe Erlang/Elixir should be used as control plane
between micro-services built with highly optimized Flow-based
programming principles?</p>
<p>Maybe this would even simultaneously solve Erlang's performance
problem, while solving Flow-based programming's problem with
[robustness of] large distributed systems? Well, one can speculate at
least. And yeah, why not also test this out in practice! :)</p>
<hr>
<p><em><strong>Note I:</strong> Interesting discussions on the post is happening on
<a href="https://news.ycombinator.com/item?id=9718868">HackerNews</a>, and the
<a href="https://groups.google.com/d/msg/flow-based-programming/6LMw6JukILY/C9SmQdlMKm8J">Flow-based programming mailing
list</a></em><br>
<em><strong>Note II:</strong> ElixirFBP creator Peter C Marks <a href="http://www.elixirfbp.org/2015/06/a-couple-of-things.html">blogged a
comment</a> of
this post and the discussion it triggered <a href="http://www.elixirfbp.org/2015/06/a-couple-of-things.html">Check it out
elixirfbp.org</a></em><br>
<em><strong>Note III:</strong> The slowness of Erlang/Elixir that I mention, is
disputed! See discussion on</em> <a href="http://www.meetup.com/stockholm-elixir/events/203279212/">this meetup
page</a><em>, and in
particular Johan Lind's</em> <a href="https://gist.github.com/samuell/dbea9f759dced60a7d0b#comment-1311551">improvements on the code example
here</a></p>

  


  </main>
  <footer>
    <p>Copyright &copy; 2024 Living Systems. All rights reserved.</p>

  </footer>
</body>
</html>
