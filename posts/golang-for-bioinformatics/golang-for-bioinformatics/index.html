<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Why didn&amp;#039;t Go get a breakthrough in bioinformatics (yet)? | Living Systems</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Why didn&amp;#039;t Go get a breakthrough in bioinformatics (yet)?</h1>

  <img src="gopherbinfie.jpg">

  
  
  <time datetime="2024-05-13T17:05:00&#43;02:00">May 13, 2024</time>

  <p><img src="/site/assets/files/1121/gopherbinfie.320x0-is.jpg" alt="A gopher doing
bioinformatics">{width=&ldquo;320&rdquo;}</p>
<p>As we are - <a href="https://a16z.com/the-century-of-biology/">according to some expert
opinions</a> - living in the
Century of Biology, I found it interesting to reflect on Go's usage
within the field.</p>
<p>Go has some great features that make it really well suited for biology,
such as:</p>
<ul>
<li>A relatively simple language that can be learned in a short time
even for people without a CS background. This is super important
aspect for biologists.</li>
<li>Fantastic support for cross-compilation into all major computer
architectures and operating systems, as static, self-sufficient
executables making it extremely simple to deploy tools, something
that can't be said about the currently most popular bio language,
Python.</li>
<li>Fantastic support for concurrency and writing code as a set of
parallell operations that streams data between them. Again, as
opposed to Python. More on that later.</li>
<li>A large standard library that contains a lot of common needs, even
for writing user interfaces and web servers.</li>
</ul>
<p>Go has in fact garnered some use for bioinformatics tools over the
years, with some indications that its use is increasing. Examples of
popular tools and toolkits are SeqKit (a veritable <em>swiss army knife</em>
for bioinformatics), the <a href="https://github.com/biogo/biogo">BioGo
toolkit</a>, lately the <a href="https://github.com/pbenner/gonetics">Gonetics
package</a>, and not the least the
<a href="https://github.com/bebop/poly">Poly</a> package for synthetic biology. And
this is besides heavy use in infrastructure-oriented projects like the
<a href="https://www.benthos.dev">Benthos</a> stream processing tool, the <a href="https://github.com/grailbio/reflow">Reflow
pipeline tool</a> and <a href="https://pachyderm.io/">Pachyderm
orchestration suite</a>.</p>
<p>Still, Go has far from had anything like a breakthrough in
bioinformatics, which is surprising given its <a href="https://twitter.com/lemire/status/1783203657426809136">incredible growth in
popularity outside the
field</a>.
CS-oriented bioinformatics folks seem to prefer the much more
complicated Rust language for implementing new tools (See e.g. this
<a href="https://www.nature.com/articles/d41586-020-03382-2">Nature articlee</a>
and <a href="https://lh3.github.io/2024/03/05/what-high-performance-language-to-learn">Heng Li's
post</a>).</p>
<p>This is to me quite surprising, as I know that for a large part of the
bioinformatics community, learning a language like Rust will pretty much
remain elusive because of the excessively steep learning curve, leading
to an even deeper division in the bio community between tool <em>makers</em>
and tool <em>consumers</em>. To me, Go seems much more like a language that
could reasonably lessen this divide, and cater both to many tool
developers, as well as people who less frequently write new tools but
perhaps sometimes want to port some homegrown scripts into compiled code
for speed.</p>
<p>This got me to start to reflect on the status of Go as a routine
language for bioinformatics. To put my thoughts into perspective, I need
to start from the beginning though, with a small personal lookback.</p>
<h3 id="a-personal-lookback">A personal lookback</h3>
<p>When I just started out my career as a bioinformatician, I pretty soon
found myself looking for a good compiled language to learn as a
completent to Python, for when the speed of a scripting language would
not be enough.</p>
<p>I scoured the web for languages, and even organized some <a href="https://docs.google.com/spreadsheets/d/1BAiJR026ih1U8HoRw__nzbCSFnnHicWrjxpW5l6-O3w/edit?usp=sharing">crowd-sourcing
of languages to
watch</a>,
as well as later some <a href="https://github.com/samuell/gccontent-benchmark#readme">benchmarking of a few of these
languages</a>.</p>
<p>What I was looking for was something that would be close to the feel of
Python where it is really easy to just open a file and read it line by
line, and write the output to another file, but that would be compiled
and fast, to be able to process the increasingly huge amounts of
sequencing data being produced.</p>
<p>I was initially interested especially in the D language, mainly because
the syntax for reading files felt so fluent and natural:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-d" data-lang="d"><span style="display:flex;"><span><span style="color:#f92672">import</span> std.stdio<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">foreach</span><span style="color:#f92672">(</span>line<span style="color:#f92672">;</span> stdin<span style="color:#f92672">.</span><span style="color:#a6e22e">byLine</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    writeln<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Got input line: &#34;</span><span style="color:#f92672">,</span> line<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>But later, in part because of recommendation by some peers to bet on Go
because of the Google backing, I ended up heavily invested in Go
instead. I eventually found a fascination with the concurrency
primitives of Go which I played around with a lot, which resulted in
libraries like <a href="https://scipipe.org/">SciPipe</a> and
<a href="https://github.com/flowbase/flowbase">FlowBase</a>, and also some
<a href="https://bionics.it/posts/crystal-concurrency-easier-syntax-than-golang">comparisons with other languages with similar features like with
Crystal</a>.</p>
<p>And the concurrency primitives is also why I eventually stuck with Go as
one of my go-to languages. This is because it seems that a lot of
bioinformatics problems are naturally modelled as pipelines of
operations to happen on a stream of data, and the concurrency primitives
in Go (channels and goroutines) makes it exceedingly easy to build such
pipelines in a way that allows to run each process on a separate CPU
core.</p>
<p>Something that has continuously bothered me with Go though is how clunky
it is for working with files, which is the bread and butter of
bioinformatics work for various reasons. Compare the above D code
example with the following similar code written in Go:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;bufio&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanner</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bufio</span>.<span style="color:#a6e22e">NewScanner</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">scanner</span>.<span style="color:#a6e22e">Scan</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">scanner</span>.<span style="color:#a6e22e">Text</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Got input line:&#34;</span>, <span style="color:#a6e22e">line</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">scanner</span>.<span style="color:#a6e22e">Err</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintln</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;error reading standard input:&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So, just to open a file for writing, you need to instantiate a buffered
scanner, and remember all the unnatural APIs for scanning and retreiving
the text from the scan, not to mention the whole error handling thing.
From 4 lines of code in D, to 12 lines in Go (excluding closing braces).</p>
<p>This, I think, is one large explanation to why Go has never really had a
breakthrough in the larger bioinformatics community. For a seasoned
programmer this is not a big deal as they are used to looking things up
in documentation as they go, and also recognize common patterns of
things that need to happen under the hood to read a file anyway. But for
the average bioinformatician, this level of complexity and nitty-gritty
details is simply a no-starter. Through enormous efforts the
bioinformatics community has trained hordes of biologists to be somewhat
familiar with basic Python scripts and perhaps a few Bash commands. But
getting them to be comfortable with this level of detail will simply not
happen in the foreseeable future.</p>
<p>But, again, I think this is a shame. Because with the concurrency
primitives and generally good performance of Go, it actually suites a
lot of bioinformatics workfloads excellently.</p>
<p>I wonder if and what could be done to make the simple things, like
reading and writing files, easy in a future version of Go?</p>
<h3 id="addendum-i-why-not-crystal">Addendum I: Why not Crystal?</h3>
<p>I realize I should comment a bit about why I haven't gone with
<a href="https://crystal-lang.org/">Crystal</a>. Crystal is a super curious
language in that it has the kind of fluent syntax I'm looking for
(heavily inspired by Ruby), <a href="https://lh3.github.io/2020/05/17/fast-high-level-programming-languages">has performed pretty well in some
comparisons</a>,
and also sports Go-like concurrency primitives, as demonstrated by <a href="https://bionics.it/posts/crystal-concurrency-easier-syntax-than-golang">my
previous
comparisons</a>,
but is plagued by seemingly inherently exponentially long compile times
hindering effective development of larger projects, and <a href="https://github.com/crystal-lang/crystal/issues/9285">limitations in
its cross-platform
compatibility</a>. If
these issues could be addressed, I'd be very interested in
re-evaluating it!</p>
<h3 id="addendum-ii-what-are-some-other-contenders">Addendum II: What are some other contenders?</h3>
<p>Apart from Rust and Crystal, and as you can see from my list of compiled
languages, there are a lot of potential alternatives for a go-to
compiled, fast language for bioinformatics. One of the most interesting
ones I'm aware of right now are <a href="https://www.julialang.org/">Julia</a> and
<a href="https://ziglang.org/">Zig</a>. While Julia <a href="https://www.nature.com/articles/s41592-023-01832-z">has been picking up usage in
biology quite a
bit</a>, it isn't a
properly compiled language though, but rather a scripting language
providing speedups via just-in-time compilation. It doesn't to my
knowledge (yet) have a great story for ahead-of-time compilation of
statically linked binaries. Zig remains an interesting langauge because
its very close integration with the C programming language (C programs
are also valid Zig programs, which means you can even just use Zig as a
more modern compiler and toolchain for compiling C code). I think we
have yet to see any major uptake of Zig in the bioinformatics community
too. And, then there is <a href="https://docs.modular.com/mojo">Mojo</a>. But I
think Mojo is way to young to say anything with confidence about how it
will develop or be able to gain a foothold in bioinformatics.</p>
<p>Samuel Lampa (<a href="https://twitter.com/smllmp">@smllmp</a>)</p>
<p><strong>Note:</strong> Some discussion is happening around the post on
<a href="https://x.com/smllmp/status/1790800748508311681">Twitter</a> and
<a href="https://www.reddit.com/r/golang/comments/1ctj5q1/why_didnt_go_get_a_breakthrough_in_bioinformatics/">Reddit</a></p>
<hr>
<p><strong>Edit history:</strong><br>
Edit 2024-05-15, 20:07: Added mention of Benthos<br>
Edit 2024-05-16, 19:08: Correction: processes -&gt; goroutines (Thanks
<a href="https://twitter.com/MihaiTodor">Mihai Todor</a>!)<br>
Edit 2024-05-16, 19:31: Added addendum about Crystal (Thanks <a href="https://twitter.com/alexanderadam__">Alexander
Adam</a> for raising the question!)<br>
Edit 2024-05-16, 19:45: Added addendum about Julia and Zig too (Thanks
again to <a href="https://twitter.com/MihaiTodor">Mihai Todor</a> for bringing up
Zig!)<br>
Edit 2024-05-16, 19:50~: Added comment about Mojo.<br>
Edit 2024-05-16, 20:02: Improved intro.<br>
Edit 2024-05-17, 11:59: Improved intro again with more reasoning on why
Go is a good suggestion for bio in the first place.</p>

  


  </main>
  <footer>
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
