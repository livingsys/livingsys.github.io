<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>How I would like to write Go programs | Living Systems</title>

      <link rel="stylesheet" href="/css/main.min.0a062e1fd1fd023b5bddc54370019169be4022da587623f7783189ac23d60d39.css" integrity="sha256-CgYuH9H9Ajtb3cVDcAGRab5AItpYdiP3eDGJrCPWDTk=" crossorigin="anonymous">


      <script src="/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js" integrity="sha256-I80MfYNyY7nq65buLZzPopadqj&#43;gD6HB/ocBqbhyUaE=" crossorigin="anonymous"></script>



</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>How I would like to write Go programs</h1>

  
  
  <time datetime="2015-07-18T02:34:00&#43;02:00">July 18, 2015</time>

  <p><p class="image">
    <img src="selection_301.png" alt=""  />
</p>
</p>
<p>Some time ago I got a <a href="http://blog.gopheracademy.com/composable-pipelines-pattern">post published on
GopherAcademy</a>,
outlining in detail how I think a <a href="http://www.jpaulmorrison.com/fbp">flow-based
programming</a> inspired syntax can
strongly help to create clearer, easier-to-maintain, and more
declarative Go programs.</p>
<p>These ideas have since became clearer, and we (<a href="http://twitter.com/ola_spjuth">Ola
Spjuth</a>'s <a href="http://www.farmbio.uu.se/research/researchgroups/pb/">research group at
pharmbio</a>) have
successfully used them to make the workflow syntax for
<a href="https://github.com/spotify/luigi">Luigi</a> (Spotify's great workflow
engine by <a href="http://twitter.com/fulhack">Erik Bernhardsson</a> &amp; co)
workflows easier, as implemented in the <a href="https://github.com/samuell/sciluigi#readme">SciLuigi helper
library</a>.</p>
<p>I even <a href="http://bionics.it/posts/fbp-data-flow-syntax">blogged the other
day</a>, about how I think
this kind of syntax would help untangle the syntax used in most
functional languages. But the final code example in that blog post was a
toy example in python, that didn't work, since python doesn't have the
required concurrent features to make it work.</p>
<p>So, the idea struck me tonight that it might be easy enough to implement
the same example in Go, using the most up-to-date ideas for the syntax.
One hour later, I have a working Go example!</p>
<p>Find it in <a href="https://gist.github.com/samuell/4d9625dbc3623fed771d#file-dataflow_syntax_example-go-L16-L32">this
gist</a>,
<a href="http://play.golang.org/p/2_uJwnk7zS">golang play</a> or in the pasted
version just below! Watch out especially for those lines connecting the
(asynchronous) processes together. That is, these lines:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>split.In  = hisay.Out
</span></span><span style="display:flex;"><span>lower.In  = split.OutLeft
</span></span><span style="display:flex;"><span>upper.In  = split.OutRight
</span></span><span style="display:flex;"><span>zippr.In1 = lower.Out
</span></span><span style="display:flex;"><span>zippr.In2 = upper.Out
</span></span><span style="display:flex;"><span>prntr.In  = zippr.Out
</span></span></code></pre></div><p>In summary: This is how I want to write composable Go programs!
(Especially if I can find a nicer way to drive the network, than a
hard-coded for-loop ;) - ideas welcome)</p>
<p>And so the full code example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#00f">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">&#34;math&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> (
</span></span><span style="display:flex;"><span>    BUFSIZE = 16
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// ======= Main =======
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Init processes
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    hisay := NewHiSayer()
</span></span><span style="display:flex;"><span>    split := NewStringSplitter()
</span></span><span style="display:flex;"><span>    lower := NewLowerCaser()
</span></span><span style="display:flex;"><span>    upper := NewUpperCaser()
</span></span><span style="display:flex;"><span>    zippr := NewZipper()
</span></span><span style="display:flex;"><span>    prntr := NewPrinter()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Network definition *** This is where to look! ***
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    split.In = hisay.Out
</span></span><span style="display:flex;"><span>    lower.In = split.OutLeft
</span></span><span style="display:flex;"><span>    upper.In = split.OutRight
</span></span><span style="display:flex;"><span>    zippr.In1 = lower.Out
</span></span><span style="display:flex;"><span>    zippr.In2 = upper.Out
</span></span><span style="display:flex;"><span>    prntr.In = zippr.Out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Set up processes for running (spawn go-routines)
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#00f">go</span> hisay.Run()
</span></span><span style="display:flex;"><span>    <span style="color:#00f">go</span> split.Run()
</span></span><span style="display:flex;"><span>    <span style="color:#00f">go</span> lower.Run()
</span></span><span style="display:flex;"><span>    <span style="color:#00f">go</span> upper.Run()
</span></span><span style="display:flex;"><span>    <span style="color:#00f">go</span> zippr.Run()
</span></span><span style="display:flex;"><span>    prntr.Run()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println(<span style="color:#a31515">&#34;Finished program!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// ======= HiSayer =======
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> hiSayer <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    Out <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> NewHiSayer() *hiSayer {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> &amp;hiSayer{Out: make(<span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>, BUFSIZE)}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> (proc *hiSayer) Run() {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">defer</span> close(proc.Out)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> _, i := <span style="color:#00f">range</span> []<span style="color:#2b91af">int</span>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {
</span></span><span style="display:flex;"><span>        proc.Out &lt;- fmt.Sprintf(<span style="color:#a31515">&#34;Hi for the %d:th time!&#34;</span>, i)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// ======= StringSplitter =======
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> stringSplitter <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    In       <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>    OutLeft  <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>    OutRight <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> NewStringSplitter() *stringSplitter {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> &amp;stringSplitter{
</span></span><span style="display:flex;"><span>        OutLeft:  make(<span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>, BUFSIZE),
</span></span><span style="display:flex;"><span>        OutRight: make(<span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>, BUFSIZE),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> (proc *stringSplitter) Run() {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">defer</span> close(proc.OutLeft)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">defer</span> close(proc.OutRight)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> s := <span style="color:#00f">range</span> proc.In {
</span></span><span style="display:flex;"><span>        halfLen := int(math.Floor(float64(len(s)) / float64(2)))
</span></span><span style="display:flex;"><span>        proc.OutLeft &lt;- s[0:halfLen]
</span></span><span style="display:flex;"><span>        proc.OutRight &lt;- s[halfLen:len(s)]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// ======= LowerCaser =======
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> lowerCaser <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    In  <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>    Out <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> NewLowerCaser() *lowerCaser {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> &amp;lowerCaser{Out: make(<span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>, BUFSIZE)}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> (proc *lowerCaser) Run() {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">defer</span> close(proc.Out)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> s := <span style="color:#00f">range</span> proc.In {
</span></span><span style="display:flex;"><span>        proc.Out &lt;- strings.ToLower(s)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// ======= UpperCaser =======
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> upperCaser <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    In  <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>    Out <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> NewUpperCaser() *upperCaser {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> &amp;upperCaser{Out: make(<span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>, BUFSIZE)}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> (proc *upperCaser) Run() {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">defer</span> close(proc.Out)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> s := <span style="color:#00f">range</span> proc.In {
</span></span><span style="display:flex;"><span>        proc.Out &lt;- strings.ToUpper(s)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// ======= Merger =======
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> zipper <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    In1 <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>    In2 <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>    Out <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> NewZipper() *zipper {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> &amp;zipper{Out: make(<span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>, BUFSIZE)}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> (proc *zipper) Run() {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">defer</span> close(proc.Out)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> {
</span></span><span style="display:flex;"><span>        s1, ok1 := &lt;-proc.In1
</span></span><span style="display:flex;"><span>        s2, ok2 := &lt;-proc.In2
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> !ok1 &amp;&amp; !ok2 {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        proc.Out &lt;- fmt.Sprint(s1, s2)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// ======= Printer =======
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> printer <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    In <span style="color:#00f">chan</span> <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> NewPrinter() *printer {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> &amp;printer{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> (proc *printer) Run() {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> s := <span style="color:#00f">range</span> proc.In {
</span></span><span style="display:flex;"><span>        fmt.Println(s)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And if we run it, we get:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go run dataflow_syntax_test.go
</span></span><span style="display:flex;"><span>hi <span style="color:#00f">for</span> the  1:TH TIME!
</span></span><span style="display:flex;"><span>hi <span style="color:#00f">for</span> the  2:TH TIME!
</span></span><span style="display:flex;"><span>hi <span style="color:#00f">for</span> the  3:TH TIME!
</span></span><span style="display:flex;"><span>hi <span style="color:#00f">for</span> the  4:TH TIME!
</span></span><span style="display:flex;"><span>hi <span style="color:#00f">for</span> the  5:TH TIME!
</span></span><span style="display:flex;"><span>hi <span style="color:#00f">for</span> the  6:TH TIME!
</span></span><span style="display:flex;"><span>hi <span style="color:#00f">for</span> the  7:TH TIME!
</span></span><span style="display:flex;"><span>hi <span style="color:#00f">for</span> the  8:TH TIME!
</span></span><span style="display:flex;"><span>hi <span style="color:#00f">for</span> the  9:TH TIME!
</span></span><span style="display:flex;"><span>hi <span style="color:#00f">for</span> the  10:TH TIME!
</span></span><span style="display:flex;"><span>Finished program!
</span></span></code></pre></div><hr>
<p><em><strong>Note I:</strong> See also <a href="https://plus.google.com/u/0/+SamuelLampa/posts/GKgBLeeJXdX">this very interesting discussion on
Google+</a>.<br>
<strong>Note II:</strong> ... and also <a href="https://groups.google.com/forum/#!topic/golang-nuts/vgj_d-MjUHA">this super-interesting discussion on
golang-nuts mailing
list</a>
(See especially <a href="https://groups.google.com/d/msg/golang-nuts/vgj_d-MjUHA/T9sE64Yrcq0J">the example and mini-FBP-framework
suggested</a>
by <a href="http://twitter.com/egonelbre">Egon Elbre</a>)<br>
<strong>Note III:</strong> For clarity, I should mention that I'm fully aware of
<a href="http://twitter.com/sibiroff">Vladimir Sibiroff</a>'s great
<a href="https://github.com/trustmaster/goflow">GoFlow</a> library, which <a href="http://github.com/samuell/blow">I've
been playing with</a>, and the development
of which I'm following closely. But I have wanted to see how far one
can go without a framework at all, just using an FBP-like pattern and
syntax, since I think a few FBP-inspired ideas can benefit also those
programs that need to stay away from frameworks for one reason or
another. This post presents what I have came up with so far (very much
inspired by GoFlow by the way!).<br>
<strong>Note IV</strong> (Jul 19, '15, 3:49 CET): Have updated the code examples
with some of the great suggestions by</em> <a href="http://twitter.com/egonelbre">Egon
Elbre</a><em>, now allowing to skip the
&quot;driving loop&quot;. To demonstrate this more nicely, I have added a
&quot;zipper&quot; and &quot;printer&quot; component, that are more suited as
terminating processes. See the</em> <a href="https://groups.google.com/d/msg/golang-nuts/vgj_d-MjUHA/qQMij-plrgQJ">mailing list
thread</a>
<em>for more info.</em></p>
<hr>
<p><em><strong>Edit I:</strong> Made code example terser, after feedback from <a href="https://twitter.com/rolflampa">Rolf
Lampa</a>.<br>
<strong>Edit II:</strong> Added missing channel close statements.</em><br>
<em><strong>Edit III:</strong> Fix data races introduced by switching channels after a
go-routine had started reading from it (Spotted by <a href="https://plus.google.com/+YannHodique/posts">Yann
Hodique</a> in <a href="https://plus.google.com/+SamuelLampa/posts/GKgBLeeJXdX">this
thread</a>,
thanks!)</em><br>
<em><strong>Edit IV:</strong> Defer the channel closeing to avoid prematurely closing
channels, as pointed out by <a href="http://twitter.com/egonelbre">Egon Elbre</a>
in <a href="https://groups.google.com/d/msg/golang-nuts/vgj_d-MjUHA/T9sE64Yrcq0J">this
thread</a>.<br>
<strong>Edit V:</strong> A better &quot;driver loop&quot;, using the ok-values from read
channels.</em></p>

  


  </main>
  <footer>
    <p>Copyright &copy; 2024 Living Systems. All rights reserved.</p>

  </footer>
</body>
</html>
