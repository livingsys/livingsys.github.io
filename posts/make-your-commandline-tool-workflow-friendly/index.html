<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Make your commandline tool workflow friendly | Living Systems</title>

      <link rel="stylesheet" href="/css/main.min.f3a5991997d3edfa6612acd25887dbae0ca5be329567cceb3054217da27f5132.css" integrity="sha256-86WZGZfT7fpmEqzSWIfbrgylvjKVZ8zrMFQhfaJ/UTI=" crossorigin="anonymous">


      <script src="/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js" integrity="sha256-I80MfYNyY7nq65buLZzPopadqj&#43;gD6HB/ocBqbhyUaE=" crossorigin="anonymous"></script>


</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Make your commandline tool workflow friendly</h1>

  
  
  <time datetime="2018-05-25T23:59:00&#43;02:00">May 25, 2018</time>

  <!-- raw HTML omitted -->
<hr>
<p>There are a number of pitfalls that can make a commandline program
really hard to integrate into a workflow (or &quot;pipeline&quot;) framework.
The reason is that many workflow tools use output file paths to keep
track of the state of the tasks producing these files. This is done for
example to know which tasks are finished and can be skipped upon a
re-run, and which are not.</p>
<p>To make the interaction between workflow tools and commandline programs
as easy as possible, the tools should generally avoid overly clever ways
of specifying them. The optimal is often to be as explicit as possible
while allowing the user (and thus the workflow tool) as much flexibility
and control as possible over each output file path.</p>
<p>Before jumping in, just a disclaimer that I have experience from
integrating tools primarily in <a href="https://galaxyproject.org/">Galaxy</a>
(though quite a years ago),
<a href="https://github.com/spotify/luigi">Luigi</a>/<a href="https://github.com/pharmbio/sciluigi">SciLuigi</a>
and <a href="http://scipipe.org">SciPipe</a>, and can not talk for all tools.
Exceptions might exist, due to other ways of handling file paths.
Generally though, I expect the same principles to apply to the majority
of workflow tools which integrate commandline programs writing to a
POSIX file system. Let's dive in:</p>
<h2 id="recommandations-to-commandline-interface-designers">Recommandations to commandline interface designers</h2>
<ol>
<li><em>Optimally</em>, allow to customize completely the file name of every
output file generated by the tool.
<ul>
<li>Motivation: Workflow tools are often configured to detect if a
certain output from a tool already exists, to enable to restart
a halted workflow from already finished intermediate results.
This will get most robust and correct if the workflow tool can
tell the commandline program exactly which file names to write
to.</li>
</ul>
</li>
<li>If you for any reason can not reasonably take the exact file name
for every output file (such as when producing a very large number of
outputs), but need to take just a file name pattern - do allow to
specify <strong>output folder</strong>, in addition to the <strong>file name pattern</strong>.
<ul>
<li>Motivation: Not being able to specify the output folder, means
that output files might be written directly to the folder were
the workflow is running, which can mess up the folder of files,
and even accidentally over-write existing files, if any name
clashes exist.</li>
</ul>
</li>
<li>Don't put limits on which file extensions (<code>.tsv</code>, <code>.png</code> etc) can
be used for output files.
<ul>
<li>Motivation: Some workflow tools add an own extension, such as
<code>.tmp</code>, after the original file name, while the file is being
written, and rename it to the correct file name after
completion, so as to guarantee atomic writes.</li>
</ul>
</li>
</ol>
<p>For the workflow tools I have the most experience with, following these
rules, should make integrating your commandline program way easier, more
robust, and reproducible.</p>
<p>Do you have more suggestions? Please add them in the comments section!</p>
<p><em><strong>Update (May 26):</strong> <a href="https://twitter.com/bjoerngruening">Björn
Grüning</a> maintains <a href="https://github.com/bgruening/coding_for_big_data">a more extensive
list of
recommendations</a>,
including some of the above points<br>
<strong>Update (May 26):</strong> If you're interested, <a href="https://twitter.com/smllmp/status/1000135015194296320">here is the twitter
thread</a> that
sparked the idea of this post.<br>
<strong>Update (May 27):</strong> <a href="https://twitter.com/ctitusbrown">Titus Brown</a> has
a <a href="https://github.com/ctb/titus-blog/blob/add/command_line_patterns/src/2018-our-command-line-patterns.md">blog post in the
works</a>,
<a href="https://twitter.com/ctitusbrown/status/1000735471062806528">announced
here</a>, and
<a href="https://github.com/ctb/titus-blog/pull/21">discussions summarized
here</a>.<br>
<strong>Update (May 27):</strong> Just learned that <a href="https://twitter.com/jmmv">Julio
Merino</a> has a <a href="http://julio.meroh.net/series.html#CLI%20design">post series from 2013 on CLI
design</a>.<br>
<strong>Update (May 2019):</strong> A paper incorporating the above considerations is
published: <a href="https://academic.oup.com/gigascience/article/8/5/giz054/5497810">Software engineering for scientific big data
analysis</a>.</em></p>

  


  </main>
  <footer>
    <p>Copyright &copy; 2024 Living Systems. All rights reserved.</p>

  </footer>
</body>
</html>
