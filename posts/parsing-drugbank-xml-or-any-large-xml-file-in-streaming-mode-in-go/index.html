<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Parsing DrugBank XML (or any large XML file) in streaming mode in Go | Living Systems</title>

      <link rel="stylesheet" href="/css/main.min.c11645622300898541e1ba6a090a08898a6e2a2f204875343a09f514ed41aadd.css" integrity="sha256-wRZFYiMAiYVB4bpqCQoIiYpuKi8gSHU0Ogn1FO1Bqt0=" crossorigin="anonymous">


      <script src="/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js" integrity="sha256-I80MfYNyY7nq65buLZzPopadqj&#43;gD6HB/ocBqbhyUaE=" crossorigin="anonymous"></script>



</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Parsing DrugBank XML (or any large XML file) in streaming mode in Go</h1>

  
  
  <time datetime="2018-03-15T15:19:00&#43;01:00">March 15, 2018</time>

  <!-- raw HTML omitted -->
<p>While Go's XML stream-parsing support is great, the details of how to
do that in a streaming fashion was not immediately clear from the docs,
and I was thus saved by <a href="http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/" target="_blank" rel="noopener">this blog
post</a>
 by
<a href="http://twitter.com/dps" target="_blank" rel="noopener">David Singleton</a>
. Basically, you could use his
blog post as a starting point, but I wanted to write up my own post to
document some specifics and peculiarities I figured out.</p>
<h2 id="idea-parse-drugbank-xml-to-tsv">Idea: Parse DrugBank XML to TSV</h2>
<p>So in short, we want to parse the DrugBank XML, which contains tons of
hierarchical information about each drug in the dataset, and extract
just a few fields, and output that into a nicely formatted tab-separated
(.tsv) file.</p>
<p>The fields which we want to extract in this example (which is based on
my real world problem mentioned above) for each drug are:</p>
<ul>
<li>InchiKey (a hashed ID representing a chemical structure)</li>
<li>Approved/Withdrawn status</li>
<li>ChEMBL ID (for the compound)</li>
<li>PubChem Compound ID (CID)</li>
<li>PubChem Substance ID (SID)</li>
</ul>
<h2 id="the-drugbank-xml-format">The DrugBank XML format</h2>
<p>The DrugBank XML format is a pretty simple one on its highest level: It
is basically a lot of &lt;drug&gt;&lt;/drug&gt; elements thrown into a
&lt;drugbank&gt;&lt;/drugbank&gt; enclosing tag. The relative complexity comes
within the &lt;drug&gt; tag. But because of how Go parses XML to structs
using tags, we can just skip most of that info, and only focus on the
parts we are interested in.</p>
<p>A schematic example of the DrugBank XML containing only the fields we
are interested could look like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#00f">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style="display:flex;"><span>&lt;drugbank xmlns=<span style="color:#a31515">&#34;http://www.drugbank.ca&#34;</span> xmlns:xsi=<span style="color:#a31515">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span> xsi:schemaLocation=<span style="color:#a31515">&#34;http://www.drugbank.ca http://www.drugbank.ca/docs/drugbank.xsd&#34;</span> version=<span style="color:#a31515">&#34;5.0&#34;</span> exported-on=<span style="color:#a31515">&#34;2017-12-20&#34;</span>&gt;
</span></span><span style="display:flex;"><span>&lt;drug type=<span style="color:#a31515">&#34;small molecule&#34;</span> created=<span style="color:#a31515">&#34;2005-06-13&#34;</span> updated=<span style="color:#a31515">&#34;2017-12-19&#34;</span>&gt;
</span></span><span style="display:flex;"><span>  &lt;name&gt;Bivalirudin&lt;/name&gt;
</span></span><span style="display:flex;"><span>  &lt;groups&gt;
</span></span><span style="display:flex;"><span>    &lt;group&gt;approved&lt;/group&gt;
</span></span><span style="display:flex;"><span>    &lt;group&gt;investigational&lt;/group&gt;
</span></span><span style="display:flex;"><span>  &lt;/groups&gt;
</span></span><span style="display:flex;"><span>  &lt;external-identifiers&gt;
</span></span><span style="display:flex;"><span>    &lt;external-identifier&gt;
</span></span><span style="display:flex;"><span>      &lt;resource&gt;PubChem Compound&lt;/resource&gt;
</span></span><span style="display:flex;"><span>      &lt;identifier&gt;16129704&lt;/identifier&gt;
</span></span><span style="display:flex;"><span>    &lt;/external-identifier&gt;
</span></span><span style="display:flex;"><span>    &lt;external-identifier&gt;
</span></span><span style="display:flex;"><span>      &lt;resource&gt;PubChem Substance&lt;/resource&gt;
</span></span><span style="display:flex;"><span>      &lt;identifier&gt;46507415&lt;/identifier&gt;
</span></span><span style="display:flex;"><span>    &lt;/external-identifier&gt;
</span></span><span style="display:flex;"><span>    &lt;external-identifier&gt;
</span></span><span style="display:flex;"><span>      &lt;resource&gt;ChEMBL&lt;/resource&gt;
</span></span><span style="display:flex;"><span>      &lt;identifier&gt;CHEMBL2103749&lt;/identifier&gt;
</span></span><span style="display:flex;"><span>    &lt;/external-identifier&gt;
</span></span><span style="display:flex;"><span>  &lt;/external-identifiers&gt;
</span></span><span style="display:flex;"><span>  &lt;calculated-properties&gt;
</span></span><span style="display:flex;"><span>    &lt;property&gt;
</span></span><span style="display:flex;"><span>      &lt;kind&gt;InChIKey&lt;/kind&gt;
</span></span><span style="display:flex;"><span>      &lt;value&gt;OIRCOABEOLEUMC-GEJPAHFPSA-N&lt;/value&gt;
</span></span><span style="display:flex;"><span>      &lt;source&gt;ChemAxon&lt;/source&gt;
</span></span><span style="display:flex;"><span>    &lt;/property&gt;
</span></span><span style="display:flex;"><span>  &lt;/calculated-properties&gt;
</span></span><span style="display:flex;"><span>&lt;/drug&gt;
</span></span><span style="display:flex;"><span>&lt;/drugbank&gt;
</span></span></code></pre></div><p>(In reality, each &lt;drug&gt; element is far far many more lines than this,
which really necessitates proper XML parsing tools).</p>
<h2 id="mapping-xml-to-go-structs">Mapping XML to Go Structs</h2>
<p>The parsing strategy for XML in Go, is the same as for other formats
such as JSON: Define one or more structs into which we parse certain XML
elements and attributes. The mapping between XML (or JSON) and the
struct fields are done using so called &quot;tags&quot; which are added within
back-quotes after the fields in the struct definition. Thus, defining
sensible structs and XML element-to-struct field mappings is the core of
the work, and will directly influence how easy your code will be to work
with.</p>
<p>Below you can see the struct-structure (sounds just right, right?) I
defined to be able to parse out the data I'm interested in:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#00f">type</span> Drugbank <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    XMLName xml.Name <span style="color:#a31515">`xml:&#34;drugbank&#34;`</span>
</span></span><span style="display:flex;"><span>    Drugs   []Drug   <span style="color:#a31515">`xml:&#34;drug&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> Drug <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    XMLName              xml.Name             <span style="color:#a31515">`xml:&#34;drug&#34;`</span>
</span></span><span style="display:flex;"><span>    Name                 <span style="color:#2b91af">string</span>               <span style="color:#a31515">`xml:&#34;name&#34;`</span>
</span></span><span style="display:flex;"><span>    Groups               []<span style="color:#2b91af">string</span>             <span style="color:#a31515">`xml:&#34;groups&gt;group&#34;`</span>
</span></span><span style="display:flex;"><span>    CalculatedProperties []Property           <span style="color:#a31515">`xml:&#34;calculated-properties&gt;property&#34;`</span>
</span></span><span style="display:flex;"><span>    ExternalIdentifiers  []ExternalIdentifier <span style="color:#a31515">`xml:&#34;external-identifiers&gt;external-identifier&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> Property <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    XMLName xml.Name <span style="color:#a31515">`xml:&#34;property&#34;`</span>
</span></span><span style="display:flex;"><span>    Kind    <span style="color:#2b91af">string</span>   <span style="color:#a31515">`xml:&#34;kind&#34;`</span>
</span></span><span style="display:flex;"><span>    Value   <span style="color:#2b91af">string</span>   <span style="color:#a31515">`xml:&#34;value&#34;`</span>
</span></span><span style="display:flex;"><span>    Source  <span style="color:#2b91af">string</span>   <span style="color:#a31515">`xml:&#34;source&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> ExternalIdentifier <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    XMLName    xml.Name <span style="color:#a31515">`xml:&#34;external-identifier&#34;`</span>
</span></span><span style="display:flex;"><span>    Resource   <span style="color:#2b91af">string</span>   <span style="color:#a31515">`xml:&#34;resource&#34;`</span>
</span></span><span style="display:flex;"><span>    Identifier <span style="color:#2b91af">string</span>   <span style="color:#a31515">`xml:&#34;identifier&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can note the following:</p>
<ul>
<li>As said, the stuff within back-quotes represent the structure in the
XML to be mapped to a certain field.</li>
<li>Note how, for nested hierarchies, we need multiple struct types,
such as the &quot;Property&quot; and &quot;ExternalIdentifier&quot; ones ... which
are then linked to from the main &quot;Drug&quot; struct&quot;.</li>
<li>We also need a struct for the highest level element, &lt;drugbank&gt;.</li>
<li>Each struct needs to have a field of xml.Name type (named XMLName
for simplicity), that defines its name in the XML, so that we have
somewhere to add our XML-mapping tag.</li>
<li>Note, when we have a slice (&quot;list&quot;) of things, such as the
&quot;CalculatedProperties&quot; field in the &quot;Drug&quot; struct, how we need
to specify a two level path
(`xml:&quot;calculated-properties**&gt;**property&quot;`) into the XML
structure, so that we get down to the individual &quot;property&quot; XML
elements which are placed inside a grouping
&quot;calculated-properties&quot; element.</li>
</ul>
<p>With that set up, we can create our Go code to loop over our XML file in
a streaming fashion, along the lines of David's <a href="http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/" target="_blank" rel="noopener">blog
post</a>
,
while also creating a TSV writer, which we use to stream-write our
extracted output into a new file, drugbank_extracted.tsv (imports and
main function left out for brevity):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>xmlFile, err := os.Open(<span style="color:#a31515">&#34;drugbank.xml&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> err != <span style="color:#00f">nil</span> {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#a31515">&#34;Could not open file: drugbank.xml&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tsvFile, err := os.Create(<span style="color:#a31515">&#34;drugbank_extracted.tsv&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> err != <span style="color:#00f">nil</span> {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#a31515">&#34;Could not create file: drugbank_extracted.tsv&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tsvWrt := csv.NewWriter(tsvFile)
</span></span><span style="display:flex;"><span>tsvWrt.Comma = <span style="color:#a31515">&#39;\t&#39;</span>
</span></span><span style="display:flex;"><span>tsvHeader := []<span style="color:#2b91af">string</span>{<span style="color:#a31515">&#34;inchikey&#34;</span>, <span style="color:#a31515">&#34;status&#34;</span>, <span style="color:#a31515">&#34;chembl_id&#34;</span>, <span style="color:#a31515">&#34;pubchem_sid&#34;</span>, <span style="color:#a31515">&#34;pubchem_cid&#34;</span>}
</span></span><span style="display:flex;"><span>tsvWrt.Write(tsvHeader)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// Implement a streaming XML parser according to guide in
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// http://blog.davidsingleton.org/parsing-huge-xml-files-with-go
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>xmlDec := xml.NewDecoder(xmlFile)
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> {
</span></span><span style="display:flex;"><span>    t, tokenErr := xmlDec.Token()
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> tokenErr != <span style="color:#00f">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> tokenErr == io.EOF {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>            panic(<span style="color:#a31515">&#34;Failed to read token:&#34;</span> + tokenErr.Error())
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">switch</span> startElem := t.(<span style="color:#00f">type</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> xml.StartElement:
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> startElem.Name.Local == <span style="color:#a31515">&#34;drug&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">var</span> status <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">var</span> inchiKey <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">var</span> chemblID <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">var</span> pubchemSID <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">var</span> pubchemCID <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            drug := &amp;Drug{}
</span></span><span style="display:flex;"><span>            decErr := xmlDec.DecodeElement(drug, &amp;startElem)
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> err != <span style="color:#00f">nil</span> {
</span></span><span style="display:flex;"><span>                panic(<span style="color:#a31515">&#34;Could not decode element&#34;</span> + decErr.Error())
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> _, g := <span style="color:#00f">range</span> drug.Groups {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> g == <span style="color:#a31515">&#34;approved&#34;</span> {
</span></span><span style="display:flex;"><span>                    status = <span style="color:#a31515">&#34;A&#34;</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#008000">// Withdrawn till &#34;shadow&#34; (what&#39;s the correct term?) approved status
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>                <span style="color:#00f">if</span> g == <span style="color:#a31515">&#34;withdrawn&#34;</span> {
</span></span><span style="display:flex;"><span>                    status = <span style="color:#a31515">&#34;W&#34;</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> _, p := <span style="color:#00f">range</span> drug.CalculatedProperties {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> p.Kind == <span style="color:#a31515">&#34;InChIKey&#34;</span> {
</span></span><span style="display:flex;"><span>                    inchiKey = p.Value
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> _, eid := <span style="color:#00f">range</span> drug.ExternalIdentifiers {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> eid.Resource == <span style="color:#a31515">&#34;ChEMBL&#34;</span> {
</span></span><span style="display:flex;"><span>                    chemblID = eid.Identifier
</span></span><span style="display:flex;"><span>                } <span style="color:#00f">else</span> <span style="color:#00f">if</span> eid.Resource == <span style="color:#a31515">&#34;PubChem Substance&#34;</span> {
</span></span><span style="display:flex;"><span>                    pubchemSID = eid.Identifier
</span></span><span style="display:flex;"><span>                } <span style="color:#00f">else</span> <span style="color:#00f">if</span> eid.Resource == <span style="color:#a31515">&#34;PubChem Compound&#34;</span> {
</span></span><span style="display:flex;"><span>                    pubchemCID = eid.Identifier
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            tsvWrt.Write([]<span style="color:#2b91af">string</span>{inchiKey, status, chemblID, pubchemSID, pubchemCID})
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> xml.EndElement:
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>tsvWrt.Flush()
</span></span><span style="display:flex;"><span>xmlFile.Close()
</span></span><span style="display:flex;"><span>tsvFile.Close()
</span></span></code></pre></div><h2 id="turn-into-a-reproducible-workflow-with-scipipe">Turn into a reproducible workflow with SciPipe</h2>
<p>Now, we could use SciPipe (Go-based workflow library I'm developing) to
put this into a little workflow, where we also automaticalyl download
the DrugBank data, Unzip it, and run the XML-to-TSV code. See <a href="https://gist.github.com/samuell/fc82fad39e7efda7987fc18173777f7f" target="_blank" rel="noopener">this
gist</a>

for the full workflow code.</p>
<p>To run the Go file in the gist, in short, what you need to do is:</p>
<ul>
<li>Create a file drugbank_userinfo.txt, containing your DrugBank
website username and password, on the form: USERNAME:PASSWORD</li>
<li>Install Go</li>
<li>Install scipipe with<br>
<code>go get github.com/scipipe/scipipe/...</code></li>
<li>Make sure you have curl installed. On Ubuntu:<br>
<code>sudo apt-get install curl</code></li>
</ul>
<p>Then, you should be able to run it, with:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>go run drugbank_xml_to_tsv_with_scipipe.go
</span></span></code></pre></div><h2 id="full-scipipe-workflow-code-example">Full SciPipe workflow code example</h2>
<p>I'm including the full SciPipe workflow code below as well, for the day
when Github is down ;):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#00f">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">&#34;encoding/csv&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">&#34;encoding/xml&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sp <span style="color:#a31515">&#34;github.com/scipipe/scipipe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// --------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// Workflow definition
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// --------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> main() {
</span></span><span style="display:flex;"><span>    wf := sp.NewWorkflow(<span style="color:#a31515">&#34;exvsdb&#34;</span>, 2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// DrugBank XML
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#008000">// Note: We need to prepend &#39;../&#39; to the file drugbank_userinfo.txt, because the workflow will be run in a subfolder
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    download := wf.NewProc(<span style="color:#a31515">&#34;download&#34;</span>, <span style="color:#a31515">&#34;curl -Lfv -o {o:zip} -u $(cat ../drugbank_userinfo.txt) https://www.drugbank.ca/releases/5-0-11/downloads/all-full-database&#34;</span>)
</span></span><span style="display:flex;"><span>    download.SetOut(<span style="color:#a31515">&#34;zip&#34;</span>, <span style="color:#a31515">&#34;dat/drugbank.zip&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    unzip := wf.NewProc(<span style="color:#a31515">&#34;unzip&#34;</span>, <span style="color:#a31515">`unzip -d dat/ {i:zip}; mv &#34;dat/full database.xml&#34; {o:xml}`</span>)
</span></span><span style="display:flex;"><span>    unzip.SetOut(<span style="color:#a31515">&#34;xml&#34;</span>, <span style="color:#a31515">&#34;dat/drugbank.xml&#34;</span>)
</span></span><span style="display:flex;"><span>    unzip.In(<span style="color:#a31515">&#34;zip&#34;</span>).From(download.Out(<span style="color:#a31515">&#34;zip&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    xmlToTSV := wf.NewProc(<span style="color:#a31515">&#34;xml2tsv&#34;</span>, <span style="color:#a31515">&#34;# Custom Go code with input: {i:xml} and output: {o:tsv}&#34;</span>)
</span></span><span style="display:flex;"><span>    xmlToTSV.SetOut(<span style="color:#a31515">&#34;tsv&#34;</span>, <span style="color:#a31515">&#34;{i:xml}.extr.tsv&#34;</span>)
</span></span><span style="display:flex;"><span>    xmlToTSV.In(<span style="color:#a31515">&#34;xml&#34;</span>).From(unzip.Out(<span style="color:#a31515">&#34;xml&#34;</span>))
</span></span><span style="display:flex;"><span>    xmlToTSV.CustomExecute = NewXMLToTSVFunc() <span style="color:#008000">// Getting the custom Go function in a factory method for readability
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>    wf.Run()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// --------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// DrugBank struct definitions
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// --------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> Drugbank <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    XMLName xml.Name <span style="color:#a31515">`xml:&#34;drugbank&#34;`</span>
</span></span><span style="display:flex;"><span>    Drugs   []Drug   <span style="color:#a31515">`xml:&#34;drug&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> Drug <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    XMLName              xml.Name             <span style="color:#a31515">`xml:&#34;drug&#34;`</span>
</span></span><span style="display:flex;"><span>    Name                 <span style="color:#2b91af">string</span>               <span style="color:#a31515">`xml:&#34;name&#34;`</span>
</span></span><span style="display:flex;"><span>    Groups               []<span style="color:#2b91af">string</span>             <span style="color:#a31515">`xml:&#34;groups&gt;group&#34;`</span>
</span></span><span style="display:flex;"><span>    CalculatedProperties []Property           <span style="color:#a31515">`xml:&#34;calculated-properties&gt;property&#34;`</span>
</span></span><span style="display:flex;"><span>    ExternalIdentifiers  []ExternalIdentifier <span style="color:#a31515">`xml:&#34;external-identifiers&gt;external-identifier&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> Property <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    XMLName xml.Name <span style="color:#a31515">`xml:&#34;property&#34;`</span>
</span></span><span style="display:flex;"><span>    Kind    <span style="color:#2b91af">string</span>   <span style="color:#a31515">`xml:&#34;kind&#34;`</span>
</span></span><span style="display:flex;"><span>    Value   <span style="color:#2b91af">string</span>   <span style="color:#a31515">`xml:&#34;value&#34;`</span>
</span></span><span style="display:flex;"><span>    Source  <span style="color:#2b91af">string</span>   <span style="color:#a31515">`xml:&#34;source&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> ExternalIdentifier <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    XMLName    xml.Name <span style="color:#a31515">`xml:&#34;external-identifier&#34;`</span>
</span></span><span style="display:flex;"><span>    Resource   <span style="color:#2b91af">string</span>   <span style="color:#a31515">`xml:&#34;resource&#34;`</span>
</span></span><span style="display:flex;"><span>    Identifier <span style="color:#2b91af">string</span>   <span style="color:#a31515">`xml:&#34;identifier&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// --------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// Components
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// --------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// NewXMLToTSVFunc returns a CustomExecute function to be used by the XML to TSV
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// component in the workflow above
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span><span style="color:#00f">func</span> NewXMLToTSVFunc() <span style="color:#00f">func</span>(t *sp.Task) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#00f">func</span>(t *sp.Task) {
</span></span><span style="display:flex;"><span>        fh, err := os.Open(t.InPath(<span style="color:#a31515">&#34;xml&#34;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> err != <span style="color:#00f">nil</span> {
</span></span><span style="display:flex;"><span>            sp.Fail(<span style="color:#a31515">&#34;Could not open file&#34;</span>, t.InPath(<span style="color:#a31515">&#34;xml&#34;</span>))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        tsvWrt := csv.NewWriter(t.OutIP(<span style="color:#a31515">&#34;tsv&#34;</span>).OpenWriteTemp())
</span></span><span style="display:flex;"><span>        tsvWrt.Comma = <span style="color:#a31515">&#39;\t&#39;</span>
</span></span><span style="display:flex;"><span>        tsvHeader := []<span style="color:#2b91af">string</span>{<span style="color:#a31515">&#34;inchikey&#34;</span>, <span style="color:#a31515">&#34;status&#34;</span>, <span style="color:#a31515">&#34;chembl_id&#34;</span>, <span style="color:#a31515">&#34;pubchem_sid&#34;</span>, <span style="color:#a31515">&#34;pubchem_cid&#34;</span>}
</span></span><span style="display:flex;"><span>        tsvWrt.Write(tsvHeader)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Implement a streaming XML parser according to guide in
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#008000">// http://blog.davidsingleton.org/parsing-huge-xml-files-with-go
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        xmlDec := xml.NewDecoder(fh)
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> {
</span></span><span style="display:flex;"><span>            t, tokenErr := xmlDec.Token()
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> tokenErr != <span style="color:#00f">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> tokenErr == io.EOF {
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">break</span>
</span></span><span style="display:flex;"><span>                } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>                    sp.Fail(<span style="color:#a31515">&#34;Failed to read token:&#34;</span>, tokenErr)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">switch</span> startElem := t.(<span style="color:#00f">type</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">case</span> xml.StartElement:
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> startElem.Name.Local == <span style="color:#a31515">&#34;drug&#34;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">var</span> status <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">var</span> inchiKey <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">var</span> chemblID <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">var</span> pubchemSID <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">var</span> pubchemCID <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    drug := &amp;Drug{}
</span></span><span style="display:flex;"><span>                    decErr := xmlDec.DecodeElement(drug, &amp;startElem)
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">if</span> err != <span style="color:#00f">nil</span> {
</span></span><span style="display:flex;"><span>                        sp.Fail(<span style="color:#a31515">&#34;Could not decode element&#34;</span>, decErr)
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">for</span> _, g := <span style="color:#00f">range</span> drug.Groups {
</span></span><span style="display:flex;"><span>                        <span style="color:#00f">if</span> g == <span style="color:#a31515">&#34;approved&#34;</span> {
</span></span><span style="display:flex;"><span>                            status = <span style="color:#a31515">&#34;A&#34;</span>
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        <span style="color:#008000">// Withdrawn till &#34;shadow&#34; (what&#39;s the correct term?) approved status
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>                        <span style="color:#00f">if</span> g == <span style="color:#a31515">&#34;withdrawn&#34;</span> {
</span></span><span style="display:flex;"><span>                            status = <span style="color:#a31515">&#34;W&#34;</span>
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">for</span> _, p := <span style="color:#00f">range</span> drug.CalculatedProperties {
</span></span><span style="display:flex;"><span>                        <span style="color:#00f">if</span> p.Kind == <span style="color:#a31515">&#34;InChIKey&#34;</span> {
</span></span><span style="display:flex;"><span>                            inchiKey = p.Value
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">for</span> _, eid := <span style="color:#00f">range</span> drug.ExternalIdentifiers {
</span></span><span style="display:flex;"><span>                        <span style="color:#00f">if</span> eid.Resource == <span style="color:#a31515">&#34;ChEMBL&#34;</span> {
</span></span><span style="display:flex;"><span>                            chemblID = eid.Identifier
</span></span><span style="display:flex;"><span>                        } <span style="color:#00f">else</span> <span style="color:#00f">if</span> eid.Resource == <span style="color:#a31515">&#34;PubChem Substance&#34;</span> {
</span></span><span style="display:flex;"><span>                            pubchemSID = eid.Identifier
</span></span><span style="display:flex;"><span>                        } <span style="color:#00f">else</span> <span style="color:#00f">if</span> eid.Resource == <span style="color:#a31515">&#34;PubChem Compound&#34;</span> {
</span></span><span style="display:flex;"><span>                            pubchemCID = eid.Identifier
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    tsvWrt.Write([]<span style="color:#2b91af">string</span>{inchiKey, status, chemblID, pubchemSID, pubchemCID})
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">case</span> xml.EndElement:
</span></span><span style="display:flex;"><span>                <span style="color:#00f">continue</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        tsvWrt.Flush()
</span></span><span style="display:flex;"><span>        fh.Close()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>(Code license: <a href="https://unlicense.org/" target="_blank" rel="noopener">Public Domain</a>
)</p>
<p><em><strong>Note I (2018-03-21):</strong> <a href="https://twitter.com/yokofakun" target="_blank" rel="noopener">Pierre
Lindenbaum</a>
 <a href="https://twitter.com/yokofakun/status/976488405654736896" target="_blank" rel="noopener">kindly
suggested</a>
 an
<a href="https://gist.github.com/lindenb/5a76d95397a86b860386cdf3976726a2" target="_blank" rel="noopener">alternative
approach</a>

using the
<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/xjc.html" target="_blank" rel="noopener">xjc</a>

tool to generate Java code, and a Makefile to provide for workflow
functionality (<a href="https://gist.github.com/lindenb/5a76d95397a86b860386cdf3976726a2" target="_blank" rel="noopener">see
code</a>
).
He also <a href="https://twitter.com/yokofakun/status/976515166002204673" target="_blank" rel="noopener">provided a
version</a>

implemented with XSLT (<a href="https://gist.github.com/lindenb/63c85ee0e8c21b6cc3e7d44b77dd93db" target="_blank" rel="noopener">see
code</a>
).</em></p>
<p><em><strong>Note II (2018-03-21):</strong> <a href="https://www.reddit.com/r/golang/comments/854zl8/data_science_parsing_drugbank_xml_or_any_large" target="_blank" rel="noopener">Some comments on the post on
reddit</a>
.</em></p>
<p><em><strong>Edit 2018-03-20:</strong> Clarification of general usefulness of parsing the
DrugBank XML in the intro.</em></p>
<p><em><strong>Edit 2018-06-16:</strong> Update code examples to new <a href="https://github.com/scipipe/scipipe/releases/tag/v0.7" target="_blank" rel="noopener">SciPipe 0.7
API</a>
 (Use From()
instead of Connect() for connections)</em></p>
<p><em><strong>Edit 2019-03-02:</strong> Update code examples to new <a href="https://github.com/scipipe/scipipe/releases/tag/v0.8.0" target="_blank" rel="noopener">SciPipe 0.8
API</a>
 (Use
SetOut() instead of SetPathStatic(), SetPathExtend() etc)</em></p>

  


  </main>
  <footer>
    <p>Copyright &copy; 2024 Living Systems. All rights reserved.</p>

  </footer>
</body>
</html>
