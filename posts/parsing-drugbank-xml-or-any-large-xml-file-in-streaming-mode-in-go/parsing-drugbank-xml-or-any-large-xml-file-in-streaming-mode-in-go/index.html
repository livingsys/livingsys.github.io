<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Parsing DrugBank XML (or any large XML file) in streaming mode in Go | Living Systems</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Parsing DrugBank XML (or any large XML file) in streaming mode in Go</h1>

  <img src="">

  
  
  <time datetime="2018-03-15T15:19:00&#43;01:00">March 15, 2018</time>

  <!-- raw HTML omitted -->
<p>While Go's XML stream-parsing support is great, the details of how to
do that in a streaming fashion was not immediately clear from the docs,
and I was thus saved by <a href="http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/">this blog
post</a> by
<a href="http://twitter.com/dps">David Singleton</a>. Basically, you could use his
blog post as a starting point, but I wanted to write up my own post to
document some specifics and peculiarities I figured out.</p>
<h2 id="idea-parse-drugbank-xml-to-tsv">Idea: Parse DrugBank XML to TSV</h2>
<p>So in short, we want to parse the DrugBank XML, which contains tons of
hierarchical information about each drug in the dataset, and extract
just a few fields, and output that into a nicely formatted tab-separated
(.tsv) file.</p>
<p>The fields which we want to extract in this example (which is based on
my real world problem mentioned above) for each drug are:</p>
<ul>
<li>InchiKey (a hashed ID representing a chemical structure)</li>
<li>Approved/Withdrawn status</li>
<li>ChEMBL ID (for the compound)</li>
<li>PubChem Compound ID (CID)</li>
<li>PubChem Substance ID (SID)</li>
</ul>
<h2 id="the-drugbank-xml-format">The DrugBank XML format</h2>
<p>The DrugBank XML format is a pretty simple one on its highest level: It
is basically a lot of &lt;drug&gt;&lt;/drug&gt; elements thrown into a
&lt;drugbank&gt;&lt;/drugbank&gt; enclosing tag. The relative complexity comes
within the &lt;drug&gt; tag. But because of how Go parses XML to structs
using tags, we can just skip most of that info, and only focus on the
parts we are interested in.</p>
<p>A schematic example of the DrugBank XML containing only the fields we
are interested could look like this:</p>
<pre><code>lang-xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;drugbank xmlns=&quot;http://www.drugbank.ca&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.drugbank.ca http://www.drugbank.ca/docs/drugbank.xsd&quot; version=&quot;5.0&quot; exported-on=&quot;2017-12-20&quot;&gt;
&lt;drug type=&quot;small molecule&quot; created=&quot;2005-06-13&quot; updated=&quot;2017-12-19&quot;&gt;
  &lt;name&gt;Bivalirudin&lt;/name&gt;
  &lt;groups&gt;
    &lt;group&gt;approved&lt;/group&gt;
    &lt;group&gt;investigational&lt;/group&gt;
  &lt;/groups&gt;
  &lt;external-identifiers&gt;
    &lt;external-identifier&gt;
      &lt;resource&gt;PubChem Compound&lt;/resource&gt;
      &lt;identifier&gt;16129704&lt;/identifier&gt;
    &lt;/external-identifier&gt;
    &lt;external-identifier&gt;
      &lt;resource&gt;PubChem Substance&lt;/resource&gt;
      &lt;identifier&gt;46507415&lt;/identifier&gt;
    &lt;/external-identifier&gt;
    &lt;external-identifier&gt;
      &lt;resource&gt;ChEMBL&lt;/resource&gt;
      &lt;identifier&gt;CHEMBL2103749&lt;/identifier&gt;
    &lt;/external-identifier&gt;
  &lt;/external-identifiers&gt;
  &lt;calculated-properties&gt;
    &lt;property&gt;
      &lt;kind&gt;InChIKey&lt;/kind&gt;
      &lt;value&gt;OIRCOABEOLEUMC-GEJPAHFPSA-N&lt;/value&gt;
      &lt;source&gt;ChemAxon&lt;/source&gt;
    &lt;/property&gt;
  &lt;/calculated-properties&gt;
&lt;/drug&gt;
&lt;/drugbank&gt;
</code></pre>
<p>(In reality, each &lt;drug&gt; element is far far many more lines than this,
which really necessitates proper XML parsing tools).</p>
<h2 id="mapping-xml-to-go-structs">Mapping XML to Go Structs</h2>
<p>The parsing strategy for XML in Go, is the same as for other formats
such as JSON: Define one or more structs into which we parse certain XML
elements and attributes. The mapping between XML (or JSON) and the
struct fields are done using so called &quot;tags&quot; which are added within
back-quotes after the fields in the struct definition. Thus, defining
sensible structs and XML element-to-struct field mappings is the core of
the work, and will directly influence how easy your code will be to work
with.</p>
<p>Below you can see the struct-structure (sounds just right, right?) I
defined to be able to parse out the data I'm interested in:</p>
<pre><code>lang-go
type Drugbank struct {
    XMLName xml.Name `xml:&quot;drugbank&quot;`
    Drugs   []Drug   `xml:&quot;drug&quot;`
}

type Drug struct {
    XMLName              xml.Name             `xml:&quot;drug&quot;`
    Name                 string               `xml:&quot;name&quot;`
    Groups               []string             `xml:&quot;groups&gt;group&quot;`
    CalculatedProperties []Property           `xml:&quot;calculated-properties&gt;property&quot;`
    ExternalIdentifiers  []ExternalIdentifier `xml:&quot;external-identifiers&gt;external-identifier&quot;`
}

type Property struct {
    XMLName xml.Name `xml:&quot;property&quot;`
    Kind    string   `xml:&quot;kind&quot;`
    Value   string   `xml:&quot;value&quot;`
    Source  string   `xml:&quot;source&quot;`
}

type ExternalIdentifier struct {
    XMLName    xml.Name `xml:&quot;external-identifier&quot;`
    Resource   string   `xml:&quot;resource&quot;`
    Identifier string   `xml:&quot;identifier&quot;`
}
</code></pre>
<p>We can note the following:</p>
<ul>
<li>As said, the stuff within back-quotes represent the structure in the
XML to be mapped to a certain field.</li>
<li>Note how, for nested hierarchies, we need multiple struct types,
such as the &quot;Property&quot; and &quot;ExternalIdentifier&quot; ones ... which
are then linked to from the main &quot;Drug&quot; struct&quot;.</li>
<li>We also need a struct for the highest level element, &lt;drugbank&gt;.</li>
<li>Each struct needs to have a field of xml.Name type (named XMLName
for simplicity), that defines its name in the XML, so that we have
somewhere to add our XML-mapping tag.</li>
<li>Note, when we have a slice (&quot;list&quot;) of things, such as the
&quot;CalculatedProperties&quot; field in the &quot;Drug&quot; struct, how we need
to specify a two level path
(`xml:&quot;calculated-properties**&gt;**property&quot;`) into the XML
structure, so that we get down to the individual &quot;property&quot; XML
elements which are placed inside a grouping
&quot;calculated-properties&quot; element.</li>
</ul>
<p>With that set up, we can create our Go code to loop over our XML file in
a streaming fashion, along the lines of David's <a href="http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/">blog
post</a>,
while also creating a TSV writer, which we use to stream-write our
extracted output into a new file, drugbank_extracted.tsv (imports and
main function left out for brevity):</p>
<pre><code>lang-go
xmlFile, err := os.Open(&quot;drugbank.xml&quot;)
if err != nil {
    panic(&quot;Could not open file: drugbank.xml&quot;)
}

tsvFile, err := os.Create(&quot;drugbank_extracted.tsv&quot;)
if err != nil {
    panic(&quot;Could not create file: drugbank_extracted.tsv&quot;)
}

tsvWrt := csv.NewWriter(tsvFile)
tsvWrt.Comma = '\t'
tsvHeader := []string{&quot;inchikey&quot;, &quot;status&quot;, &quot;chembl_id&quot;, &quot;pubchem_sid&quot;, &quot;pubchem_cid&quot;}
tsvWrt.Write(tsvHeader)

// Implement a streaming XML parser according to guide in
// http://blog.davidsingleton.org/parsing-huge-xml-files-with-go
xmlDec := xml.NewDecoder(xmlFile)
for {
    t, tokenErr := xmlDec.Token()
    if tokenErr != nil {
        if tokenErr == io.EOF {
            break
        } else {
            panic(&quot;Failed to read token:&quot; + tokenErr.Error())
        }
    }
    switch startElem := t.(type) {
    case xml.StartElement:
        if startElem.Name.Local == &quot;drug&quot; {
            var status string
            var inchiKey string
            var chemblID string
            var pubchemSID string
            var pubchemCID string

            drug := &amp;Drug{}
            decErr := xmlDec.DecodeElement(drug, &amp;startElem)
            if err != nil {
                panic(&quot;Could not decode element&quot; + decErr.Error())
            }
            for _, g := range drug.Groups {
                if g == &quot;approved&quot; {
                    status = &quot;A&quot;
                }
                // Withdrawn till &quot;shadow&quot; (what's the correct term?) approved status
                if g == &quot;withdrawn&quot; {
                    status = &quot;W&quot;
                }
            }
            for _, p := range drug.CalculatedProperties {
                if p.Kind == &quot;InChIKey&quot; {
                    inchiKey = p.Value
                }
            }

            for _, eid := range drug.ExternalIdentifiers {
                if eid.Resource == &quot;ChEMBL&quot; {
                    chemblID = eid.Identifier
                } else if eid.Resource == &quot;PubChem Substance&quot; {
                    pubchemSID = eid.Identifier
                } else if eid.Resource == &quot;PubChem Compound&quot; {
                    pubchemCID = eid.Identifier
                }
            }

            tsvWrt.Write([]string{inchiKey, status, chemblID, pubchemSID, pubchemCID})
        }
    case xml.EndElement:
        continue
    }
}
tsvWrt.Flush()
xmlFile.Close()
tsvFile.Close()
</code></pre>
<h2 id="turn-into-a-reproducible-workflow-with-scipipe">Turn into a reproducible workflow with SciPipe</h2>
<p>Now, we could use SciPipe (Go-based workflow library I'm developing) to
put this into a little workflow, where we also automaticalyl download
the DrugBank data, Unzip it, and run the XML-to-TSV code. See <a href="https://gist.github.com/samuell/fc82fad39e7efda7987fc18173777f7f">this
gist</a>
for the full workflow code.</p>
<p>To run the Go file in the gist, in short, what you need to do is:</p>
<ul>
<li>Create a file drugbank_userinfo.txt, containing your DrugBank
website username and password, on the form: USERNAME:PASSWORD</li>
<li>Install Go</li>
<li>Install scipipe with<br>
<code>go get github.com/scipipe/scipipe/...</code></li>
<li>Make sure you have curl installed. On Ubuntu:<br>
<code>sudo apt-get install curl</code></li>
</ul>
<p>Then, you should be able to run it, with:</p>
<pre><code>lang-bash
go run drugbank_xml_to_tsv_with_scipipe.go
</code></pre>
<h2 id="full-scipipe-workflow-code-example">Full SciPipe workflow code example</h2>
<p>I'm including the full SciPipe workflow code below as well, for the day
when Github is down ;):</p>
<pre><code>lang-go
package main

import (
    &quot;encoding/csv&quot;
    &quot;encoding/xml&quot;
    &quot;io&quot;
    &quot;os&quot;

    sp &quot;github.com/scipipe/scipipe&quot;
)

// --------------------------------------------------------------------------------
// Workflow definition
// --------------------------------------------------------------------------------

func main() {
    wf := sp.NewWorkflow(&quot;exvsdb&quot;, 2)

    // DrugBank XML
    // Note: We need to prepend '../' to the file drugbank_userinfo.txt, because the workflow will be run in a subfolder
    download := wf.NewProc(&quot;download&quot;, &quot;curl -Lfv -o {o:zip} -u $(cat ../drugbank_userinfo.txt) https://www.drugbank.ca/releases/5-0-11/downloads/all-full-database&quot;)
    download.SetOut(&quot;zip&quot;, &quot;dat/drugbank.zip&quot;)

    unzip := wf.NewProc(&quot;unzip&quot;, `unzip -d dat/ {i:zip}; mv &quot;dat/full database.xml&quot; {o:xml}`)
    unzip.SetOut(&quot;xml&quot;, &quot;dat/drugbank.xml&quot;)
    unzip.In(&quot;zip&quot;).From(download.Out(&quot;zip&quot;))

    xmlToTSV := wf.NewProc(&quot;xml2tsv&quot;, &quot;# Custom Go code with input: {i:xml} and output: {o:tsv}&quot;)
    xmlToTSV.SetOut(&quot;tsv&quot;, &quot;{i:xml}.extr.tsv&quot;)
    xmlToTSV.In(&quot;xml&quot;).From(unzip.Out(&quot;xml&quot;))
    xmlToTSV.CustomExecute = NewXMLToTSVFunc() // Getting the custom Go function in a factory method for readability

    wf.Run()
}

// --------------------------------------------------------------------------------
// DrugBank struct definitions
// --------------------------------------------------------------------------------

type Drugbank struct {
    XMLName xml.Name `xml:&quot;drugbank&quot;`
    Drugs   []Drug   `xml:&quot;drug&quot;`
}

type Drug struct {
    XMLName              xml.Name             `xml:&quot;drug&quot;`
    Name                 string               `xml:&quot;name&quot;`
    Groups               []string             `xml:&quot;groups&gt;group&quot;`
    CalculatedProperties []Property           `xml:&quot;calculated-properties&gt;property&quot;`
    ExternalIdentifiers  []ExternalIdentifier `xml:&quot;external-identifiers&gt;external-identifier&quot;`
}

type Property struct {
    XMLName xml.Name `xml:&quot;property&quot;`
    Kind    string   `xml:&quot;kind&quot;`
    Value   string   `xml:&quot;value&quot;`
    Source  string   `xml:&quot;source&quot;`
}

type ExternalIdentifier struct {
    XMLName    xml.Name `xml:&quot;external-identifier&quot;`
    Resource   string   `xml:&quot;resource&quot;`
    Identifier string   `xml:&quot;identifier&quot;`
}

// --------------------------------------------------------------------------------
// Components
// --------------------------------------------------------------------------------

// NewXMLToTSVFunc returns a CustomExecute function to be used by the XML to TSV
// component in the workflow above
func NewXMLToTSVFunc() func(t *sp.Task) {
    return func(t *sp.Task) {
        fh, err := os.Open(t.InPath(&quot;xml&quot;))
        if err != nil {
            sp.Fail(&quot;Could not open file&quot;, t.InPath(&quot;xml&quot;))
        }

        tsvWrt := csv.NewWriter(t.OutIP(&quot;tsv&quot;).OpenWriteTemp())
        tsvWrt.Comma = '\t'
        tsvHeader := []string{&quot;inchikey&quot;, &quot;status&quot;, &quot;chembl_id&quot;, &quot;pubchem_sid&quot;, &quot;pubchem_cid&quot;}
        tsvWrt.Write(tsvHeader)

        // Implement a streaming XML parser according to guide in
        // http://blog.davidsingleton.org/parsing-huge-xml-files-with-go
        xmlDec := xml.NewDecoder(fh)
        for {
            t, tokenErr := xmlDec.Token()
            if tokenErr != nil {
                if tokenErr == io.EOF {
                    break
                } else {
                    sp.Fail(&quot;Failed to read token:&quot;, tokenErr)
                }
            }
            switch startElem := t.(type) {
            case xml.StartElement:
                if startElem.Name.Local == &quot;drug&quot; {
                    var status string
                    var inchiKey string
                    var chemblID string
                    var pubchemSID string
                    var pubchemCID string

                    drug := &amp;Drug{}
                    decErr := xmlDec.DecodeElement(drug, &amp;startElem)
                    if err != nil {
                        sp.Fail(&quot;Could not decode element&quot;, decErr)
                    }
                    for _, g := range drug.Groups {
                        if g == &quot;approved&quot; {
                            status = &quot;A&quot;
                        }
                        // Withdrawn till &quot;shadow&quot; (what's the correct term?) approved status
                        if g == &quot;withdrawn&quot; {
                            status = &quot;W&quot;
                        }
                    }
                    for _, p := range drug.CalculatedProperties {
                        if p.Kind == &quot;InChIKey&quot; {
                            inchiKey = p.Value
                        }
                    }

                    for _, eid := range drug.ExternalIdentifiers {
                        if eid.Resource == &quot;ChEMBL&quot; {
                            chemblID = eid.Identifier
                        } else if eid.Resource == &quot;PubChem Substance&quot; {
                            pubchemSID = eid.Identifier
                        } else if eid.Resource == &quot;PubChem Compound&quot; {
                            pubchemCID = eid.Identifier
                        }
                    }

                    tsvWrt.Write([]string{inchiKey, status, chemblID, pubchemSID, pubchemCID})
                }
            case xml.EndElement:
                continue
            }
        }
        tsvWrt.Flush()
        fh.Close()
    }
}
</code></pre>
<p>(Code license: <a href="https://unlicense.org/">Public Domain</a>)</p>
<p><em><strong>Note I (2018-03-21):</strong> <a href="https://twitter.com/yokofakun">Pierre
Lindenbaum</a> <a href="https://twitter.com/yokofakun/status/976488405654736896">kindly
suggested</a> an
<a href="https://gist.github.com/lindenb/5a76d95397a86b860386cdf3976726a2">alternative
approach</a>
using the
<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/xjc.html">xjc</a>
tool to generate Java code, and a Makefile to provide for workflow
functionality (<a href="https://gist.github.com/lindenb/5a76d95397a86b860386cdf3976726a2">see
code</a>).
He also <a href="https://twitter.com/yokofakun/status/976515166002204673">provided a
version</a>
implemented with XSLT (<a href="https://gist.github.com/lindenb/63c85ee0e8c21b6cc3e7d44b77dd93db">see
code</a>).</em></p>
<p><em><strong>Note II (2018-03-21):</strong> <a href="https://www.reddit.com/r/golang/comments/854zl8/data_science_parsing_drugbank_xml_or_any_large">Some comments on the post on
reddit</a>.</em></p>
<p><em><strong>Edit 2018-03-20:</strong> Clarification of general usefulness of parsing the
DrugBank XML in the intro.</em></p>
<p><em><strong>Edit 2018-06-16:</strong> Update code examples to new <a href="https://github.com/scipipe/scipipe/releases/tag/v0.7">SciPipe 0.7
API</a> (Use From()
instead of Connect() for connections)</em></p>
<p><em><strong>Edit 2019-03-02:</strong> Update code examples to new <a href="https://github.com/scipipe/scipipe/releases/tag/v0.8.0">SciPipe 0.8
API</a> (Use
SetOut() instead of SetPathStatic(), SetPathExtend() etc)</em></p>

  


  </main>
  <footer>
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
