<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Profiling and creating call graphs for Go programs | Living Systems</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Profiling and creating call graphs for Go programs</h1>

  <img src="basecompl_blow_callgraph_crop.png">

  
  
  <time datetime="2013-08-08T01:13:00&#43;02:00">August 8, 2013</time>

  <p>In trying to get my head around the code of the very interesting
<a href="https://github.com/trustmaster/goflow">GoFlow</a> library, (for flow-based
programming in Go), and the accompanying <a href="https://github.com/samuell/blow">flow-based bioinformatics
library</a> I started hacking on, I needed
to get some kind of visualization (like a call graph) ... something
like this:</p>
<p><img src="/site/assets/files/1101/basecompl_blow_callgraph_1.640x0-is.png" alt="">{width=&ldquo;640&rdquo;}</p>
<p>(And in the end, that is what I got ... read on ... ) :)</p>
<p>I then found out about the go tool pprof command, for which the Go team
published a <a href="http://blog.golang.org/profiling-go-programs">blog post</a> on
<a href="http://blog.golang.org/profiling-go-programs">here</a>.</p>
<p>Being a Go newbie, I must admit I had quite a hard time deciphering the
blog post though. Maybe it was just a psychological barrier because of
all the technological anechdotes, that made it look harder than it
actually was. Anyhow, it didn't help that &quot;go run pprof&quot; didn't
produce any output if I didn't run processing on a large enough file
that it would have time to collect data.</p>
<p>Anyways, with this in mind I wanted to make a slightly easier-to-follow
instruction for newbies like me, on how to use &quot;go tool pprof&quot; for
profiling and producing call graphs ... but then after I published this
post, <a href="http://twitter.com/davecheney">Dave Cheney</a> pinged me about his
excellent
<strong><a href="http://dave.cheney.net/2013/07/07/introducing-profile-super-simple-profiling-for-go-programs">profile</a></strong>
package, which makes the process even easier, so I went away and updated
the blog post to include how to do it both with the profile package, AND
with the pprof library itself! :)</p>
<p>Ok, so enough blather, let's get started:</p>
<h2 id="toc0">Easy option: Profiling Go programs with the profile package</h2>
<h3 id="toc1">Easy option Overview: What you will do</h3>
<ul>
<li>First you will need to put a very small code snippet in your code,
that will output a profile-file (named [something].pprof in your
/tmp/ folder) when you run your program.</li>
<li>This profile file can then be used with the &quot;go run pprof&quot; command
to do various things like output reports of top functions taking
time, and not the least, producing a <strong>graphical call graph</strong>, which
is what I was most interested in here.</li>
</ul>
<h3 id="toc2">Easy option Step 0: Install profile</h3>
<p>If you have your GOROOT and GOPATH environment variables correctly
setup, you should be able to install it with this simple command:</p>
<pre><code>go get github.com/davecheney/profile
</code></pre>
<p>... otherwise you'll have to install it manually from
<a href="http://github.com/davecheney/profile">http://github.com/davecheney/profile</a></p>
<h3 id="toc3">Easy option Step 1: Add a line of code, to produce a profile file</h3>
<ul>
<li>
<p>Add &quot;github.com/davecheney/profile&quot; to your import statement.
Something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span> <span style="color:#a6e22e">your</span> <span style="color:#a6e22e">other</span> <span style="color:#a6e22e">imports</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;github.com/davecheney/profile&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div></li>
<li>
<p>Add the following line <strong>at the beginning</strong> of your main() function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">profile</span>.<span style="color:#a6e22e">Start</span>(<span style="color:#a6e22e">profile</span>.<span style="color:#a6e22e">CPUProfile</span>).<span style="color:#a6e22e">Stop</span>()
</span></span></code></pre></div></li>
</ul>
<p>&hellip; the result should be something like:</p>
<pre><code>```go
func main() {
    defer profile.Start(profile.CPUProfile).Stop()
 
    // ... your main code here ...
}
```
</code></pre>
<h3 id="toc4">Easy option Step 2: Build your program as usual</h3>
<p>Something like:</p>
<pre><code>go build [your program].go
</code></pre>
<h3 id="toc5">Easy option, Step 3: Run your program long enough to get some profiling data</h3>
<ul>
<li>
<p>Now run your program as usual</p>
<ul>
<li>Note: Make sure it rung long enough to gather data! I had to run
my DNA-processing code on a 58MB file rather than my 7.8KB test
file I was using first, to get predictable results.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./<span style="color:#f92672">[</span>your program<span style="color:#f92672">]</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="toc6">Easy option, Step 4: Copy the cpu.pprof file from /tmp/...</h3>
<p>When running the program in the previous step, you will have seen some
output like this:</p>
<pre><code>2013/08/08 16:45:58 profile: cpu profiling enabled, /tmp/profile882806532/cpu.pprof
</code></pre>
<p>Copy this file to where you are standing right now, with:</p>
<pre><code>cp /tmp/profile[some number]/cpu.pprof .
</code></pre>
<p><em>Read on from <a href="http://saml.rilspace.com/profiling-and-creating-call-graphs-for-go-programs-with-go-tool-pprof#rest">step
4</a>,
for the rest of the steps ...</em></p>
<h2 id="toc7">Hard option: Using the pprof library directly</h2>
<h3 id="toc8">Hard option Overview: What you will do</h3>
<ul>
<li>First you will need to put in some code snippets (more than in the
easy option) in your code, that will output a profile-file (named
[something].pprof) when you run your program.</li>
<li>This profile file can then be used with the &quot;go run pprof&quot; command
to do various things like output reports of top functions taking
time, and not the least, producing a <strong>graphical call graph</strong>, which
is what I was most interested in here.</li>
</ul>
<h3 id="toc9">Hard option Step 1: Add some code snippets to your code, to produce a profile file</h3>
<ul>
<li>
<p>Add &quot;runtime/pprof&quot; to your import statement. Something like:</p>
<p>import (
&hellip; your other imports &hellip;
&ldquo;flag&rdquo;
&ldquo;fmt&rdquo;
&ldquo;runtime/pprof&rdquo;
)</p>
</li>
<li>
<p>Add this <strong>just before</strong> your main() function:</p>
<p>// Profiling stuff &hellip; from <a href="http://blog.golang.org/profiling-go-programs">http://blog.golang.org/profiling-go-programs</a>
var cpuprofile = flag.String(&ldquo;cpuprofile&rdquo;, &ldquo;&rdquo;, &ldquo;write cpu profile to file&rdquo;)</p>
</li>
<li>
<p>Add the following code <strong>at the beginning</strong> of your main() function:</p>
<pre><code>flag.Parse()
if *cpuprofile != &quot;&quot; {
    f, err := os.Create(*cpuprofile)
    if err != nil {
        fmt.Println(&quot;Error: &quot;, err)
    }
    pprof.StartCPUProfile(f)
    defer pprof.StopCPUProfile()
}
</code></pre>
</li>
</ul>
<p>... the result should be something like:</p>
<pre><code>// Profiling stuff ... from http://blog.golang.org/profiling-go-programs
var cpuprofile = flag.String(&quot;cpuprofile&quot;, &quot;&quot;, &quot;write cpu profile to file&quot;)
 
func main() {
    flag.Parse()
    if *cpuprofile != &quot;&quot; {
        f, err := os.Create(*cpuprofile)
        if err != nil {
            fmt.Println(&quot;Error: &quot;, err)
        }
        pprof.StartCPUProfile(f)
        defer pprof.StopCPUProfile()
    }
 
       // ... your main code here ...
 
}
</code></pre>
<p>This will add a command line flag &quot;-cpuprofile&quot;, which you can later
use to specify a filename where to write the profiling data.</p>
<h3 id="toc10">Hard option Step 2: Build your program as usual</h3>
<p>Something like:</p>
<pre><code>go build [your program].go
</code></pre>
<h3 id="toc11">Hard option Step 3: Run your program long enough to get some profiling data</h3>
<ul>
<li>
<p>Now run your program, specifying a filename to the -cpuprofile flag,
where to store the profiling data</p>
<ul>
<li>Note: Make sure it rung long enough to gather data! I had to run
my DNA-processing code on a 58MB file rather than my 7.8KB test
file I was using first, to get predictable results.</li>
</ul>
<p>./[your program] -cpuprofile=cpu.pprof</p>
</li>
</ul>
<h2 id="toc12">The rest (Same for easy and hard option!)</h2>
<h3 id="toc13">Step 4: Get some nice output from your profile data</h3>
<ul>
<li>
<p>Now comes the fun part, where you can do nice stuff with your
profile data.</p>
</li>
<li>
<p>My favourite here was to output the callgraph as a PDF file:</p>
<p>go tool pprof &ndash;pdf [my program] cpu.pprof &gt; callgraph.pdf</p>
</li>
</ul>
<h3 id="toc14">Step 5: Enjoy your callgraph</h3>
<p>Let's see what that looks like:</p>
<p><img src="/site/assets/files/1101/basecompl_blow_callgraph_crop.640x0-is.png" alt="">{width=&ldquo;640&rdquo;}</p>
<p>Not too bad, no? (Find the PDF version below as well)</p>
<h3 id="toc15">Step 6: Try some other commands</h3>
<p>Some other output you might want to do:</p>
<ul>
<li>
<p>A textual report:</p>
<p>go tool pprof &ndash;text [my program] cpu.pprof &gt; report.txt</p>
</li>
<li>
<p>Check the outher options:</p>
<p>go tool pprof 2&gt;&amp;1|less</p>
</li>
</ul>
<p>(Isn't there a nicer way to get a paginated help screen?)</p>
<h3 id="toc16">Step 7: Go back to the Go team blog post and learn the advanced options</h3>
<p>Now, this might have been an easier start if you are a newbie, but then
Dave Cheney's post on <strong>profile</strong>, and the Go team blog post on
<strong>runtime/pprof</strong> contains info on more advanced use of the pprof tool,
so be sure to go back and study it:</p>
<ul>
<li><a href="http://dave.cheney.net/2013/07/07/introducing-profile-super-simple-profiling-for-go-programs">Dave Cheney - Introducing profile, super simple profiling for Go
programs</a></li>
<li><a href="http://blog.golang.org/profiling-go-programs">The Go Programming Language Blog - Profiling Go
Programs</a></li>
</ul>
<p><strong>Samuel</strong></p>

  


  </main>
  <footer>
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
