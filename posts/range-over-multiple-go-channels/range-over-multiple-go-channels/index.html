<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>(Almost) ranging over multiple Go channels simultaneously | Living Systems</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>(Almost) ranging over multiple Go channels simultaneously</h1>

  <img src="">

  
  
  <time datetime="2017-10-05T10:23:00&#43;02:00">October 5, 2017</time>

  <!-- raw HTML omitted -->
<p>Thus, optimally, one would want to use Go's handy <strong>range</strong> keyword for
looping over multiple channels, since <strong>range</strong> takes care of closing
the for-loop at the right time (when the inbound channel is closed). So
something like this (<strong>N.B:</strong> non-working code!):</p>
<pre><code>lang-go
for a, b, c := range chA, chB, chC {
    doSomething(a, b, c)
}
</code></pre>
<p>Unfortunately this is not possible, and probably for good reason (how
would it know whether to close the loop when the first, or all of the
channels are closed? etc).</p>
<p>Anyways, I started a <a href="https://twitter.com/smllmp/status/915581420143349760">twitter
thread</a> to discuss
this. Then, I read <a href="https://dave.cheney.net/2014/03/19/channel-axioms">this
post</a> by Dave Cheney
which explains what the range keyword does under the hood when looping
over channels. He pointed out that this:</p>
<pre><code>lang-go
for a := range chA {
    doSomething(a)
}
</code></pre>
<p>... is actually the same as this more detailed code:</p>
<pre><code>lang-go
for a, ok := &lt;-chA; ok; a, ok = &lt;-chA  {
    doSomething(a, b, c)
}
</code></pre>
<p>... which is using one variant of Go's for-syntax, which is:</p>
<pre><code>lang-go
for init variables; condition for continuing; what to do after each iteration  {
    doSomething(a, b, c)
}
</code></pre>
<p>See the <a href="https://golang.org/doc/effective_go.html#for">relevant section in Effective
Go</a> for more info.</p>
<p>Together with a <a href="https://twitter.com/inancgumus/status/915735236402716673">tweet by Inanc
Gumus</a> in the
mentioned thread, I realized one can do something like this with a bit
of helper functions:</p>
<pre><code>lang-go
package main

import &quot;fmt&quot;

func main() {
    bufSize := 1 // Try changing this to 0, and see what happens!
    ch1, ch2, ch3 := make(chan int, bufSize), make(chan int, bufSize), make(chan int, bufSize)
    go func() {
        defer close(ch1); defer close(ch2); defer close(ch3)
        ch1 &lt;- 1; ch2 &lt;- 2; ch3 &lt;- 3
        ch3 &lt;- 6; ch2 &lt;- 5; ch1 &lt;- 4 // Notice the reversed order of sends(!)
    }()

    // THIS IS WHERE TO LOOK:
    for rs, oks := readOnce(ch1, ch2, ch3); allTrue(oks); rs, oks = readOnce(ch1, ch2, ch3) {
        fmt.Println(rs)
    }
}

// -------------------------------------------------------------------------------
// Helper functions
// -------------------------------------------------------------------------------

func readOnce(chs ...chan int) ([]int, []bool) {
    rs := []int{}
    oks := []bool{}
    for _, ch := range chs {
        r, ok := &lt;-ch
        rs = append(rs, r)
        oks = append(oks, ok)
    }
    return rs, oks
}

func allTrue(vs []bool) bool {
    for _, v := range vs {
        if !v {
            return false
        }
    }
    return true
}
</code></pre>
<ul>
<li><a href="https://play.golang.org/p/RHnA_4Dxcl">Run this code on the Go
playground</a></li>
</ul>
<p>If we zoom in again on the interesting part:</p>
<pre><code>lang-go
for rs, oks := readOnce(ch1, ch2, ch3); allTrue(oks); rs, oks = readOnce(ch1, ch2, ch3) {
    fmt.Println(rs)
}
</code></pre>
<p>... we can see that this is pretty close to the more detailed version
of the range-loop that Dave Cheney showed above.</p>
<p>We can also note that this will work for any number of channels provided
to readOnce(), as long as it is channels of type int, and that you're
fine with getting one set of (int) results back, one array at a time, in
the loop.</p>
<p>One must keep in mind that the close condition in the loop has to be
thought-through carefully. In this example I have created the function
allTrue() that just checks that all booleans in the input array are
true, and otherwise returns false. This will close the for loop as soon
as the first channel is closed. This might be OK if we are sure that all
inbound channels will contain the same input items. If not, one will
need to adapt the close condition accordingly.</p>
<p>Anyways, I think this is at least some progress towards something as
generic as possible for reading from multiple channels simultanously and
synchronosly.</p>
<p>Also, if you have further ideas on how to make this more succinct and
generic, please let me know!</p>
<h2 id="wrap-the-range-like-code-up-in-a-helper-function">Wrap the range-like code up in a helper function</h2>
<p><em><strong>Edit:</strong> This section was added on Oct 6, 2017, 17:33 CEST</em></p>
<p>Naturally, we can now also create a helper function that wraps the
somewhat messy for-loop above, so instead we would have something like
this (see the syncRead() function):</p>
<pre><code>lang-go
package main

import &quot;fmt&quot;

func main() {
    bufSize := 1 // Try changing this to 0, and see what happens!
    ch1, ch2, ch3 := make(chan int, bufSize), make(chan int, bufSize), make(chan int, bufSize)
    go func() {
        defer close(ch1)
        defer close(ch2)
        defer close(ch3)
        ch1 &lt;- 1
        ch2 &lt;- 2
        ch3 &lt;- 3
        ch3 &lt;- 6
        ch2 &lt;- 5
        ch1 &lt;- 4 // Notice the reversed order of sends(!)
    }()

    // THIS GOT A BIT NICER NOW, RIGHT?:
    for rs := range syncRead(ch1, ch2, ch3) {
        fmt.Println(rs)
    }
}

// -- Helper funcs --------------------------------------------------------------------------------

func syncRead(chs ...chan int) chan []int {
    outChan := make(chan []int, 16)
    go func() {
        defer close(outChan)
        for rs, oks := recvOneEach(chs...); allTrue(oks); rs, oks = recvOneEach(chs...) {
            outChan &lt;- rs
        }
    }()
    return outChan
}

func recvOneEach(chs ...chan int) ([]int, []bool) {
    rs := []int{}
    oks := []bool{}
    for _, ch := range chs {
        r, ok := &lt;-ch
        rs = append(rs, r)
        oks = append(oks, ok)
    }
    return rs, oks
}

func allTrue(vs []bool) bool {
    for _, v := range vs {
        if !v {
            return false
        }
    }
    return true
}
</code></pre>
<ul>
<li><a href="https://play.golang.org/p/C1SsmxwIlb">Run this code on the Go
playground</a></li>
</ul>
<h2 id="even-better-avoid-the-alltrue-method">Even better: Avoid the allTrue method</h2>
<p><em><strong>Edit:</strong> This section was added on Dec 1, 2017, 21:56 CEST</em></p>
<p>Thanks to the suggestion by <a href="https://disqus.com/by/ar3s3ru/">ar3s3ru</a> in
the comments below, we can now also remove the allTrue helper method,
and so make the code even more succinct:</p>
<pre><code>lang-go
package main

import &quot;fmt&quot;

func main() {
    bufSize := 1 // Try changing this to 0, and see what happens!
    ch1, ch2, ch3 := make(chan int, bufSize), make(chan int, bufSize), make(chan int, bufSize)
    go func() {
        defer close(ch1)
        defer close(ch2)
        defer close(ch3)
        ch1 &lt;- 1
        ch2 &lt;- 2
        ch3 &lt;- 3
        ch3 &lt;- 6
        ch2 &lt;- 5
        ch1 &lt;- 4 // Notice the reversed order of sends(!)
    }()

    // THIS GOT A BIT NICER NOW, RIGHT?:
    for rs := range syncRead(ch1, ch2, ch3) {
        fmt.Println(rs)
    }
}

// -- Helper funcs --------------------------------------------------------------------------------

func syncRead(chs ...chan int) chan []int {
    outChan := make(chan []int, 16)
    go func() {
        defer close(outChan)
        for rs, ok := recvOneEach(chs...); ok; rs, ok = recvOneEach(chs...) {
            outChan &lt;- rs
        }
    }()
    return outChan
}

func recvOneEach(chs ...chan int) (rs []int, ok bool) {
    ok = true
    for _, ch := range chs {
        r, ok2 := &lt;-ch
        rs, ok = append(rs, r), ok &amp;&amp; ok2
    }
    return rs, ok
}
</code></pre>
<ul>
<li><a href="https://play.golang.org/p/-DmXytk_hh">Run this code on the Go
playground</a></li>
</ul>
<p>The only limitation to this is of course that the the helper functions
work only for channels of type int (and also all of them need to be of
the same type), so you would need to create separate implementations for
each type, or of course, fall back to use the empty interface (aka <a href="https://www.nivenly.com/finally-an-elegant-solutions-to-generics-in-go/">the
G
package</a>)
:o)</p>
<p><strong>Keywords:</strong> Go, Golang, Pipelines, Patterns</p>

  


  </main>
  <footer>
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
