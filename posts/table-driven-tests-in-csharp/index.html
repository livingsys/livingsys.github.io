<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Table-driven tests in C# | Living Systems</title>

      <link rel="stylesheet" href="/css/main.min.c11645622300898541e1ba6a090a08898a6e2a2f204875343a09f514ed41aadd.css" integrity="sha256-wRZFYiMAiYVB4bpqCQoIiYpuKi8gSHU0Ogn1FO1Bqt0=" crossorigin="anonymous">


      <script src="/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js" integrity="sha256-I80MfYNyY7nq65buLZzPopadqj&#43;gD6HB/ocBqbhyUaE=" crossorigin="anonymous"></script>



</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Table-driven tests in C#</h1>

  
  
  <time datetime="2019-11-02T21:24:00&#43;01:00">November 2, 2019</time>

  <p>Folks in the Go community have championed so called table-driven tests
(see e.g. <a href="https://dave.cheney.net/2019/05/07/prefer-table-driven-tests" target="_blank" rel="noopener">this post by Dave
Cheney</a>

and the <a href="https://github.com/golang/go/wiki/TableDrivenTests" target="_blank" rel="noopener">Go wiki</a>
)
as a way to quickly and easily writing up a bunch of complete test cases
with inputs and corresponding expected outputs, and looping over them to
execute the function being tested. In short, the idea is to suggest a
maximally short and convenient syntax to do this.</p>
<p>For example, given that we have a function like this in mylibrary.go:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#00f">package</span> tabletest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// Concat concats strings
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span><span style="color:#00f">func</span> Concat(a <span style="color:#2b91af">string</span>, b <span style="color:#2b91af">string</span>) <span style="color:#2b91af">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> a + b
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>... then we could write a quite compact enumeration of testcases for
testing this function like this (placing it in a file like
mylibrary_test.go):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#00f">package</span> tabletest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// TestConcat tests the Concat function
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span><span style="color:#00f">func</span> TestConcat(t *testing.T) {
</span></span><span style="display:flex;"><span>    testCases := []<span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>        str1 <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>        str2 <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>        want <span style="color:#2b91af">string</span>
</span></span><span style="display:flex;"><span>    }{
</span></span><span style="display:flex;"><span>        {str1: <span style="color:#a31515">&#34;a&#34;</span>, str2: <span style="color:#a31515">&#34;b&#34;</span>, want: <span style="color:#a31515">&#34;ab&#34;</span>},
</span></span><span style="display:flex;"><span>        {str1: <span style="color:#a31515">&#34;b&#34;</span>, str2: <span style="color:#a31515">&#34;c&#34;</span>, want: <span style="color:#a31515">&#34;bc&#34;</span>},
</span></span><span style="display:flex;"><span>        {str1: <span style="color:#a31515">&#34;c&#34;</span>, str2: <span style="color:#a31515">&#34;d&#34;</span>, want: <span style="color:#a31515">&#34;cd&#34;</span>},
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> _, tt := <span style="color:#00f">range</span> testCases {
</span></span><span style="display:flex;"><span>        have := Concat(tt.str1, tt.str2)
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> have != tt.want {
</span></span><span style="display:flex;"><span>            t.Fatalf(<span style="color:#a31515">&#34;ERROR: wanted %s but have %s\n&#34;</span>, tt.want, have)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What happens in the code above is that we are initializing an array of
an anonymous struct type (we are not even giving it a name), while also
initializing it with values. Then we loop over this array of structs and
use the data to drive the testing. The anonymous struct initialization
helps keep code short and succinct.</p>
<p>Anyways, given that in my current work at
<a href="http://www.savanticab.com/en" target="_blank" rel="noopener">Savantic</a>
 I have happened to write a lot
of C# over the last year, I was interested in whether I could write
such succinct enumerations of test cases in C# too. It turns out that
with some new syntax introduced in C# 7, it is quite possible!</p>
<p>Below is an example of how to write such a table-dirven test in C#
(using the xUnit test framework here, but should work with any test
framework).</p>
<p>First, we assume that we have function something just like the Concat
function above:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#2b91af">string</span> Concat(<span style="color:#2b91af">string</span> s1, <span style="color:#2b91af">string</span> s2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> s1 + s2;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>... then, we could write a test function like so:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#00f">using</span> System.Collections.Generic;
</span></span><span style="display:flex;"><span><span style="color:#00f">using</span> Xunit;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[Fact] <span style="color:#008000">// &lt;-- annotation required by xUnit</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">void</span> TestConcat()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#00f">foreach</span> (<span style="color:#2b91af">var</span> TC <span style="color:#00f">in</span> <span style="color:#00f">new</span> List&lt;(<span style="color:#2b91af">string</span> str1, <span style="color:#2b91af">string</span> str2, <span style="color:#2b91af">string</span> want)&gt; {
</span></span><span style="display:flex;"><span>        (str1: <span style="color:#a31515">&#34;a&#34;</span>, str2: <span style="color:#a31515">&#34;b&#34;</span>, want: <span style="color:#a31515">&#34;ab&#34;</span>),
</span></span><span style="display:flex;"><span>        (str1: <span style="color:#a31515">&#34;b&#34;</span>, str2: <span style="color:#a31515">&#34;c&#34;</span>, want: <span style="color:#a31515">&#34;bc&#34;</span>),
</span></span><span style="display:flex;"><span>        (str1: <span style="color:#a31515">&#34;c&#34;</span>, str2: <span style="color:#a31515">&#34;d&#34;</span>, want: <span style="color:#a31515">&#34;cd&#34;</span>),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Assert.Equal(TC.want, Concat(TC.str1, TC.str2));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What happens here it that we initialize a new list of an anonymous tuple
type (initialized using just parentheses), which we fill with values
... all inline in the set-up of the foreach-loop. Since we are able to
combine the initialization with the foreach loop, this is actually in a
way even more succinct than the corresponding code in Go!</p>
<p>If you are really lazy, you can actually skip the field names when
filling in the &quot;table&quot;:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#00f">using</span> System.Collections.Generic;
</span></span><span style="display:flex;"><span><span style="color:#00f">using</span> Xunit;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[Fact] <span style="color:#008000">// &lt;-- annotation required by xUnit</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">void</span> TestConcat()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#00f">foreach</span> (<span style="color:#2b91af">var</span> TC <span style="color:#00f">in</span> <span style="color:#00f">new</span> List&lt;(<span style="color:#2b91af">string</span> str1, <span style="color:#2b91af">string</span> str2, <span style="color:#2b91af">string</span> want)&gt; {
</span></span><span style="display:flex;"><span>        (<span style="color:#a31515">&#34;a&#34;</span>, <span style="color:#a31515">&#34;b&#34;</span>, <span style="color:#a31515">&#34;ab&#34;</span>),
</span></span><span style="display:flex;"><span>        (<span style="color:#a31515">&#34;b&#34;</span>, <span style="color:#a31515">&#34;c&#34;</span>, <span style="color:#a31515">&#34;bc&#34;</span>),
</span></span><span style="display:flex;"><span>        (<span style="color:#a31515">&#34;c&#34;</span>, <span style="color:#a31515">&#34;d&#34;</span>, <span style="color:#a31515">&#34;cd&#34;</span>),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Assert.Equal(TC.want, Concat(TC.str1, TC.str2));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Even less keystrokes. This is in fact not that far from editing plain
CSV, right inside C#. Only that here the data is typesafe and
compiler-checked in your editor as you type.</p>
<p>Now, I know frameworks for C# (NUnit, xUnit, MSTest etc) implement
their own ways of enumerating test input and outputs, often via
annotations on the test methods. Thus, this might not be the recommended
way to write tests in everyone's books. Still, I tend to like this
approach a lot. The fact that table-driven tests are normal Go/C# code
means there is no extra syntax to learn, the behavior is easier to
reason about, and definitely more portable between test frameworks.</p>
<p>The benefit of avoiding new syntax alone, has kept me writing tests in
this style ever since I found out it is possible.</p>
<p>I have also found this technique very handy for casees when there are
some smaller amounts of data (e.g. various kinds of default data) that
needs to be initiated into an object structure and where you want an
easy way to edit the actual data, and want to avoid repeating possibly
more complex code for setting up the object structure.</p>
<p><strong>Samuel</strong> <a href="https://twitter.com/smllmp" target="_blank" rel="noopener">@smllmp</a>
</p>

  


  </main>
  <footer>
    <p>Copyright &copy; 2024 Living Systems. All rights reserved.</p>

  </footer>
</body>
</html>
