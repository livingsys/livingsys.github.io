<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Table-driven tests in C# | Living Systems</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Table-driven tests in C#</h1>

  <img src="selection_0023.png">

  
  
  <time datetime="2019-11-02T21:24:00&#43;01:00">November 2, 2019</time>

  <p>Folks in the Go community have championed so called table-driven tests
(see e.g. <a href="https://dave.cheney.net/2019/05/07/prefer-table-driven-tests">this post by Dave
Cheney</a>
and the <a href="https://github.com/golang/go/wiki/TableDrivenTests">Go wiki</a>)
as a way to quickly and easily writing up a bunch of complete test cases
with inputs and corresponding expected outputs, and looping over them to
execute the function being tested. In short, the idea is to suggest a
maximally short and convenient syntax to do this.</p>
<p>For example, given that we have a function like this in mylibrary.go:</p>
<pre><code>lang-go
package tabletest

// Concat concats strings
func Concat(a string, b string) string {
    return a + b
}
</code></pre>
<p>... then we could write a quite compact enumeration of testcases for
testing this function like this (placing it in a file like
mylibrary_test.go):</p>
<pre><code>lang-go
package tabletest

import (
    &quot;testing&quot;
)

// TestConcat tests the Concat function
func TestConcat(t *testing.T) {
    testCases := []struct {
        str1 string
        str2 string
        want string
    }{
        {str1: &quot;a&quot;, str2: &quot;b&quot;, want: &quot;ab&quot;},
        {str1: &quot;b&quot;, str2: &quot;c&quot;, want: &quot;bc&quot;},
        {str1: &quot;c&quot;, str2: &quot;d&quot;, want: &quot;cd&quot;},
    }
    for _, tt := range testCases {
        have := Concat(tt.str1, tt.str2)
        if have != tt.want {
            t.Fatalf(&quot;ERROR: wanted %s but have %s\n&quot;, tt.want, have)
        }
    }
}
</code></pre>
<p>What happens in the code above is that we are initializing an array of
an anonymous struct type (we are not even giving it a name), while also
initializing it with values. Then we loop over this array of structs and
use the data to drive the testing. The anonymous struct initialization
helps keep code short and succinct.</p>
<p>Anyways, given that in my current work at
<a href="http://www.savanticab.com/en">Savantic</a> I have happened to write a lot
of C# over the last year, I was interested in whether I could write
such succinct enumerations of test cases in C# too. It turns out that
with some new syntax introduced in C# 7, it is quite possible!</p>
<p>Below is an example of how to write such a table-dirven test in C#
(using the xUnit test framework here, but should work with any test
framework).</p>
<p>First, we assume that we have function something just like the Concat
function above:</p>
<pre><code>lang-csharp
public string Concat(string s1, string s2)
{
    return s1 + s2;
}
</code></pre>
<p>... then, we could write a test function like so:</p>
<pre><code>lang-csharp
using System.Collections.Generic;
using Xunit;

[Fact] // &lt;-- annotation required by xUnit
public void TestConcat()
{
    foreach (var TC in new List&lt;(string str1, string str2, string want)&gt; {
        (str1: &quot;a&quot;, str2: &quot;b&quot;, want: &quot;ab&quot;),
        (str1: &quot;b&quot;, str2: &quot;c&quot;, want: &quot;bc&quot;),
        (str1: &quot;c&quot;, str2: &quot;d&quot;, want: &quot;cd&quot;),
    })
    {
        Assert.Equal(TC.want, Concat(TC.str1, TC.str2));
    }
}
</code></pre>
<p>What happens here it that we initialize a new list of an anonymous tuple
type (initialized using just parentheses), which we fill with values
... all inline in the set-up of the foreach-loop. Since we are able to
combine the initialization with the foreach loop, this is actually in a
way even more succinct than the corresponding code in Go!</p>
<p>If you are really lazy, you can actually skip the field names when
filling in the &quot;table&quot;:</p>
<pre><code>lang-csharp
using System.Collections.Generic;
using Xunit;

[Fact] // &lt;-- annotation required by xUnit
public void TestConcat()
{
    foreach (var TC in new List&lt;(string str1, string str2, string want)&gt; {
        (&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;),
        (&quot;b&quot;, &quot;c&quot;, &quot;bc&quot;),
        (&quot;c&quot;, &quot;d&quot;, &quot;cd&quot;),
    })
    {
        Assert.Equal(TC.want, Concat(TC.str1, TC.str2));
    }
}
</code></pre>
<p>Even less keystrokes. This is in fact not that far from editing plain
CSV, right inside C#. Only that here the data is typesafe and
compiler-checked in your editor as you type.</p>
<p>Now, I know frameworks for C# (NUnit, xUnit, MSTest etc) implement
their own ways of enumerating test input and outputs, often via
annotations on the test methods. Thus, this might not be the recommended
way to write tests in everyone's books. Still, I tend to like this
approach a lot. The fact that table-driven tests are normal Go/C# code
means there is no extra syntax to learn, the behavior is easier to
reason about, and definitely more portable between test frameworks.</p>
<p>The benefit of avoiding new syntax alone, has kept me writing tests in
this style ever since I found out it is possible.</p>
<p>I have also found this technique very handy for casees when there are
some smaller amounts of data (e.g. various kinds of default data) that
needs to be initiated into an object structure and where you want an
easy way to edit the actual data, and want to avoid repeating possibly
more complex code for setting up the object structure.</p>
<p><strong>Samuel</strong> <a href="https://twitter.com/smllmp">@smllmp</a></p>

  


  </main>
  <footer>
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
