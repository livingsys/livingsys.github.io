<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>The unexpected convenience of JSON on the commandline | Living Systems</title>

      <link rel="stylesheet" href="/css/main.min.0dd62280a0c008a6369ab81bd9d63c41bf7e4b5e9377c4a60df43868258f1db5.css" integrity="sha256-DdYigKDACKY2mrgb2dY8Qb9&#43;S16Td8SmDfQ4aCWPHbU=" crossorigin="anonymous">


      <script src="/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js" integrity="sha256-I80MfYNyY7nq65buLZzPopadqj&#43;gD6HB/ocBqbhyUaE=" crossorigin="anonymous"></script>



</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>The unexpected convenience of JSON on the commandline</h1>

  
  
  <time datetime="2015-12-08T07:10:00&#43;01:00">December 8, 2015</time>

  <p>I was working with a migration from <a href="http://drupal.org" target="_blank" rel="noopener">drupal</a>
 to
<a href="http://processwire.com" target="_blank" rel="noopener">processwire</a>
 CMS:es, where I wanted to be able
to pipe data, including the body field with HTML formatting and all,
through multiple processing steps in a flexible manner. I&rsquo;d start with
an extraction SQL query, through a few components to replace and massage
the data, and finally over to an import command using processwire&rsquo;s
<a href="http://wireshell.pw" target="_blank" rel="noopener">wireshell tool</a>
. So, basically I needed a flexible
format for structured data that could be sent as one &ldquo;data object&rdquo; per
line, to work nicely with linux commandline tools like grep, sed and
awk.</p>
<p>CSV didn&rsquo;t seem that suitable, because of the unpredictable HTML
formatting of the body field (though I never really tried) &hellip; and I
don&rsquo;t even know how to wrap up YAML into one-liners.</p>
<p>But then it struck me how well JSON is suited for this.</p>
<p>I&rsquo;ve heard folks using it before, and it is by no means any news to
experienced data wranglers, I&rsquo;m sure, but I just hadn&rsquo;t thought about
it.</p>
<p>JSON has excellent escaping of any kind of characters, and can be
formatted as one object per line, making it perfect for piping on the
commandline. What&rsquo;s more, working with JSON in python, is extremely
convenient, since all the typical python data structures (lists, tuples
and dicts) map directly to counterparts in JSON. This means that you can
just use json.dumps() or json.loads() to convert a nested python data
structure to and from a JSON string.</p>
<p>Although this is for sure no news for experienced commandline data
wranglers, I just wanted to illustrate just how easy this is:</p>
<p>So, for example, reading some basic info and the body field (of Drupal
7) from MySQL is as easy as:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#00f">import</span> MySQLdb <span style="color:#00f">as</span> mdb
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> json
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> sys <span style="color:#00f">import</span> stdout
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>con = mdb.connect([HOST], [USER], [PASS], [DB])
</span></span><span style="display:flex;"><span>cur = con.cursor()
</span></span><span style="display:flex;"><span>query = <span style="color:#a31515">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">        SELECT n.nid, n.type, n.created, n.title, fdb.body_value
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">        FROM node AS n
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">        LEFT JOIN field_data_body AS fdb ON n.vid = fdb.revision_id
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">        &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>cur.execute(query)
</span></span><span style="display:flex;"><span>rows = cur.fetchall()
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> row <span style="color:#00f">in</span> rows:
</span></span><span style="display:flex;"><span>    rowinfo = [i.decode(<span style="color:#a31515">&#39;latin-1&#39;</span>) <span style="color:#00f">if</span> type(i) <span style="color:#00f">is</span> str <span style="color:#00f">else</span> i <span style="color:#00f">for</span> i <span style="color:#00f">in</span> row]
</span></span><span style="display:flex;"><span>    pageinfo = {
</span></span><span style="display:flex;"><span>            <span style="color:#a31515">&#39;Nid&#39;</span>: rowinfo[0],
</span></span><span style="display:flex;"><span>            <span style="color:#a31515">&#39;NodeType&#39;</span>: rowinfo[1],
</span></span><span style="display:flex;"><span>            <span style="color:#a31515">&#39;Created&#39;</span>: rowinfo[2],
</span></span><span style="display:flex;"><span>            <span style="color:#a31515">&#39;Title&#39;</span>: rowinfo[3],
</span></span><span style="display:flex;"><span>            <span style="color:#a31515">&#39;Body&#39;</span>: rowinfo[4],
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    stdout.write(json.dumps(pageinfo) + <span style="color:#a31515">&#39;</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#39;</span>) <span style="color:#008000"># The newline is important here!</span>
</span></span></code></pre></div><p>But now, this is mostly MySQL stuff, so a smaller component might better
demonstrate how little is needed to read from json. So, say that we want
to change all occurances of &ldquo;node&rdquo; in NodeType to &ldquo;page&rdquo; (which is
the more commonly used term for what Drupal calls a node):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#00f">from</span> sys <span style="color:#00f">import</span> stdin, stdout
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> row <span style="color:#00f">in</span> stdin:
</span></span><span style="display:flex;"><span>    r = json.loads(row)
</span></span><span style="display:flex;"><span>    r[<span style="color:#a31515">&#39;NodeType&#39;</span>] = r[<span style="color:#a31515">&#39;NodeType&#39;</span>].replace(<span style="color:#a31515">&#39;node&#39;</span>, <span style="color:#a31515">&#39;page&#39;</span>)
</span></span><span style="display:flex;"><span>    stdout.write(json.dumps(r) + <span style="color:#a31515">&#39;</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#39;</span>)
</span></span></code></pre></div><p>So, this is what little is required to create a pipeable component
working with JSON data, using python!</p>
<p>So, now, we can use these two components together by just piping them,
and using the normal linux commandline tools for convenient browsing on
the commandline (such as my favorite <strong>less -Si</strong> for scrolling without
wrapping lines:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>python extractsql.py | python replace.py | less -Si
</span></span></code></pre></div><p>But, even better than custom python components, is that you have the <a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">jq
tool</a>
 available, which fits perfectly
into this workflow. In short, <strong>jq</strong> can replace all of sed, awk and
grep, in one combined package for working with json objects.</p>
<p>A more detailed foray into using jq is material for another post, but
just a simple example that would be usable here is to filter out just
the NodeType field, to see that it became correctly replaced. This is
easily achieved with jq:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>python extractsql.py | python replace.py | jq <span style="color:#a31515">&#39;.NodeType&#39;</span> | less -Si
</span></span></code></pre></div><p>As simple as that. Check the <a href="https://stedolan.github.io/jq/manual/" target="_blank" rel="noopener">jq
manual</a>
 for more usage info on
jq.</p>
<p>I&rsquo;m sure I will use JSON for piping structured data on the commandline
a lot more from now on.</p>

  
  <div>
    <div>Tags:</div>
    <ul>
        <li><a href="/tags/json/">Json</a></li>
        <li><a href="/tags/python/">Python</a></li>
    </ul>
  </div>


  </main>
  <footer>
    <p>Copyright &copy; 2024 Living Systems. All rights reserved.</p>

  </footer>
</body>
</html>
