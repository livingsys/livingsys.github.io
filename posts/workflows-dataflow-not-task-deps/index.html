<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Workflow tool makers: Allow defining data flow, not just task dependencies | Living Systems</title>

      <link rel="stylesheet" href="/css/main.min.0a062e1fd1fd023b5bddc54370019169be4022da587623f7783189ac23d60d39.css" integrity="sha256-CgYuH9H9Ajtb3cVDcAGRab5AItpYdiP3eDGJrCPWDTk=" crossorigin="anonymous">


      <script src="/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js" integrity="sha256-I80MfYNyY7nq65buLZzPopadqj&#43;gD6HB/ocBqbhyUaE=" crossorigin="anonymous"></script>



</head>
<body>
  <header>
    <h1>Living Systems</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Workflow tool makers: Allow defining data flow, not just task dependencies</h1>

  
  
  <time datetime="2015-06-10T12:03:00&#43;02:00">June 10, 2015</time>

  <h3 id="upsurge-in-workflow-tools">Upsurge in workflow tools</h3>
<p><p class="image">
    <img src="selection_201.png" alt="Workflow tool
logos"  class="align_right" />
</p>
There
seem to be a little upsurge in light-weight - often python-based -
workflow tools for data pipelines in the last couple of years:
Spotify's <a href="https://github.com/spotify/luigi">Luigi</a>, OpenStack's
<a href="https://wiki.openstack.org/wiki/Mistral">Mistral</a>, Pinterest's
<a href="https://github.com/pinterest/pinball">Pinball</a>, and recently AirBnb's
<a href="https://github.com/airbnb/airflow">Airflow</a>, to name a few. These are
all interesting tools, and it is an interesting trend for us at
<a href="http://www.farmbio.uu.se/research/researchgroups/pb/?languageId=1">pharmbio</a>,
who try to see how we can use workflow tools to automate bio- and
cheminformatics tasks on compute clusters.</p>
<h3 id="something-missing-">Something missing ...</h3>
<p>Something I consistently see among the tools though, and which surprises
me quite some, is this: <strong>Most of these tools specify dependencies
between tasks, rather than between the outputs and inputs of these
tasks</strong>.</p>
<p>As far as I have understood the code examples and screenshots, this is
the case for almost all these tools. In the case of Luigi though, at
least it was extensible enough that it was very easy to add a small
workaround to allow dependency definition between these instead of tasks
(we're in the process of packaging this up in the <a href="http://github.com/samuell/sciluigi">sciluigi
library</a>).</p>
<p>Maybe this has something to do with the nature of typical hadoop
workflows, which seem to be the primary goal of most of these tools. But
it is still unfortunate that this subtle design decision highly limits
the applicability of these tools in such a big domain as scientific
workflows.</p>
<h3 id="lets-look-at-an-example">Let's look at an example</h3>
<p>Let's for example compare one of these tools with another very common
platform in bioinformatics, which ships with workflow support built-in:
the <a href="http://galaxyproject.org/">Galaxy platform</a>. Let's compare for
example how Airflow defines dependencies directly between tasks, and how
Galaxy properly defines connections between inputs and outputs, by
looking at the graphical representation of the workflows.</p>
<p><p class="image">
    <img src="selection_200.png" alt=""  />
</p>
</p>
<p><em><strong>Airflow dependency graph</strong> (Image from the <a href="http://pythonhosted.org/airflow">AirFlow
docs</a>)</em></p>
<p><p class="image">
    <img src="peptide_workflow.png" alt=""  />
</p>
</p>
<p><em><strong>Galaxy &quot;dependency graph&quot;, or &quot;data flow network&quot;</strong>
(<a href="https://github.com/bgruening/presentations/blob/master/shared/resources/img/peptide_workflow.png">Screenshot</a>
creds: <a href="https://github.com/bgruening">Björn Grüning</a>)</em></p>
<p>Do you see how the explicitly named inputs and outputs in the Galaxy
example makes this workflow so much clearer.</p>
<p>Now, these are of course only graphs, and might not tell the full truth
about how the tool works, but you just have to look at a few code
examples, to see that this really is the case. For example, for AirFlow,
you can find an example of setting up dependencies
<a href="http://pythonhosted.org/airflow/tutorial.html#setting-up-dependencies">here</a>.
Or, see below:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#008000"># ... code for instantiating tasks t1 and t2 ...</span>
</span></span><span style="display:flex;"><span>t2.set_upstream(t1)
</span></span><span style="display:flex;"><span><span style="color:#008000"># This means that t2 will depend on t1</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># running successfully to run</span>
</span></span></code></pre></div><p>Do you see how you set the dependencies directly between the tasks (t1
and t2), without any info about inputs and outputs?</p>
<p>In the case of Galaxy, you don't define this in code, but you can draw
the connections between named outports and inports graphically.</p>
<p>And, for an example of a library that allows to do this in code, see for
example our little helper library for luigi, sciluigi, that allows this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#008000"># Run the same task on the two splits</span>
</span></span><span style="display:flex;"><span>t1 = Task1()
</span></span><span style="display:flex;"><span>t2 = Task1()
</span></span><span style="display:flex;"><span>t3 = Task2(
</span></span><span style="display:flex;"><span>        in1 = t1.outspec(<span style="color:#a31515">&#39;out1&#39;</span>)
</span></span><span style="display:flex;"><span>        in2 = t1.outspec(<span style="color:#a31515">&#39;out2&#39;</span>)
</span></span><span style="display:flex;"><span>        in3 = t2.outspec(<span style="color:#a31515">&#39;out1&#39;</span>)
</span></span><span style="display:flex;"><span>        in4 = t2.outspec(<span style="color:#a31515">&#39;out2&#39;</span>))
</span></span></code></pre></div><p>Do you see how this enables us to receive multiple outputs (out1, out2)
from multiple upstream tasks (t1, t2), into task t3 in a very clear and
explicit way?</p>
<h3 id="an-example-from-the-real-world">An example from the real world</h3>
<p>If you still don't believe that this is important, have a look at this
example workflow from a real world bioinformatics (Next Generation
Sequencing) workflow, given in a
<a href="http://uppnex.se/twiki/do/view/Courses/NgsIntro1502">course</a> at
<a href="http://www.scilifelab.se/">SciLifeLab</a> here in Uppsala/Stockholm
(implemented in a predecessor to our sciluigi library, <a href="https://github.com/samuell/luigis_monkey_wrench">luigi's monkey
wrench</a>). Look
especially for all the &quot;inports&quot; and &quot;outport&quot; parts in the code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#00f">import</span> luigi
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> luigis_monkey_wrench <span style="color:#00f">import</span> *
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>REF=<span style="color:#a31515">&#39;human_17_v37.fasta&#39;</span>
</span></span><span style="display:flex;"><span>INDIVIDUALS=[<span style="color:#a31515">&#39;NA06984&#39;</span>,<span style="color:#a31515">&#39;NA07000&#39;</span>]
</span></span><span style="display:flex;"><span>SAMPLES=[<span style="color:#a31515">&#39;1&#39;</span>,<span style="color:#a31515">&#39;2&#39;</span>]
</span></span><span style="display:flex;"><span>BASENAME=<span style="color:#a31515">&#39;.ILLUMINA.low_coverage.17q_&#39;</span>
</span></span><span style="display:flex;"><span>PICARDDIR=<span style="color:#a31515">&#39;/sw/apps/bioinfo/picard/1.69/kalkyl/&#39;</span>
</span></span><span style="display:flex;"><span>KNOWNSITES=<span style="color:#a31515">&#39;/proj/g2014207/labs/gatk/ALL.chr17.phase1_integrated_calls.20101123.snps_indels_svs.genotypes.vcf&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">class</span> <span style="color:#2b91af">GATKWorkflow</span>(WorkflowTask):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> requires(self):
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> i <span style="color:#00f">in</span> INDIVIDUALS:
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Workflow definition</span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># ---------------------------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># files() will return a pseudo task that just outputs an existing file,</span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000">#         while not running anything.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># shell() will create a new task with a command that can take inputs</span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000">#         and outputs.</span>
</span></span><span style="display:flex;"><span>            fq1 = file(<span style="color:#a31515">&#39;fastq:</span><span style="color:#a31515">{i}</span><span style="color:#a31515">/</span><span style="color:#a31515">{i}{b}</span><span style="color:#a31515">1.fq&#39;</span>.format(i=i,b=BASENAME))
</span></span><span style="display:flex;"><span>            fq2 = file(<span style="color:#a31515">&#39;fastq:</span><span style="color:#a31515">{i}</span><span style="color:#a31515">/</span><span style="color:#a31515">{i}{b}</span><span style="color:#a31515">2.fq&#39;</span>.format(i=i,b=BASENAME))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Step 2 in [1]--------------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span>            aln1 = shell(<span style="color:#a31515">&#39;bwa aln </span><span style="color:#a31515">{ref}</span><span style="color:#a31515"> &lt;i:fastq&gt; &gt; &lt;o:sai:&lt;i:fastq&gt;.sai&gt;&#39;</span>.format(ref=REF))
</span></span><span style="display:flex;"><span>            aln1.inports[<span style="color:#a31515">&#39;fastq&#39;</span>] = fq1.outport(<span style="color:#a31515">&#39;fastq&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            aln2 = shell(<span style="color:#a31515">&#39;bwa aln </span><span style="color:#a31515">{ref}</span><span style="color:#a31515"> &lt;i:fastq&gt; &gt; &lt;o:sai:&lt;i:fastq&gt;.sai&gt;&#39;</span>.format(ref=REF))
</span></span><span style="display:flex;"><span>            aln2.inports[<span style="color:#a31515">&#39;fastq&#39;</span>] = fq2.outport(<span style="color:#a31515">&#39;fastq&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Step 3 in [1]--------------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span>            merg = shell(<span style="color:#a31515">&#39;bwa sampe </span><span style="color:#a31515">{ref}</span><span style="color:#a31515"> &lt;i:sai1&gt; &lt;i:sai2&gt; &lt;i:fq1&gt; &lt;i:fq2&gt; &gt; &lt;o:merged:</span><span style="color:#a31515">{i}</span><span style="color:#a31515">/</span><span style="color:#a31515">{i}{b}</span><span style="color:#a31515">.merged.sam&gt;&#39;</span>.format(
</span></span><span style="display:flex;"><span>                ref=REF,
</span></span><span style="display:flex;"><span>                i=i,
</span></span><span style="display:flex;"><span>                b=BASENAME))
</span></span><span style="display:flex;"><span>            merg.inports[<span style="color:#a31515">&#39;sai1&#39;</span>] = aln1.outport(<span style="color:#a31515">&#39;sai&#39;</span>)
</span></span><span style="display:flex;"><span>            merg.inports[<span style="color:#a31515">&#39;sai2&#39;</span>] = aln2.outport(<span style="color:#a31515">&#39;sai&#39;</span>)
</span></span><span style="display:flex;"><span>            merg.inports[<span style="color:#a31515">&#39;fq1&#39;</span>] = fq1.outport(<span style="color:#a31515">&#39;fastq&#39;</span>)
</span></span><span style="display:flex;"><span>            merg.inports[<span style="color:#a31515">&#39;fq2&#39;</span>] = fq2.outport(<span style="color:#a31515">&#39;fastq&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Step 4a in [1]------------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span>            mergbam = shell(<span style="color:#a31515">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            java -Xmx2g -jar </span><span style="color:#a31515">{p}</span><span style="color:#a31515">/AddOrReplaceReadGroups.jar
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                INPUT=&lt;i:sam&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                OUTPUT=&lt;o:bam:&lt;i:sam&gt;.bam&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                SORT_ORDER=coordinate
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                RGID=</span><span style="color:#a31515">{sample}</span><span style="color:#a31515">-id
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                RGLB=</span><span style="color:#a31515">{sample}</span><span style="color:#a31515">-lib
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                RGPL=ILLUMINA
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                RGPU=</span><span style="color:#a31515">{sample}</span><span style="color:#a31515">-01
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                RGSM=</span><span style="color:#a31515">{sample}</span><span style="color:#a31515">
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            &#39;&#39;&#39;</span>.format(
</span></span><span style="display:flex;"><span>                 p=PICARDDIR,
</span></span><span style="display:flex;"><span>                 sample=i))
</span></span><span style="display:flex;"><span>            mergbam.inports[<span style="color:#a31515">&#39;sam&#39;</span>] = merg.outport(<span style="color:#a31515">&#39;merged&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Step 4b in [1] -----------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span>            index_mergbam = shell(<span style="color:#a31515">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            java -Xmx2g -jar
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                /sw/apps/bioinfo/picard/1.69/kalkyl/BuildBamIndex.jar
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                INPUT=&lt;i:bamr
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                # &lt;o:bai:&lt;i:bam:.bam|.bai&gt;&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            &#39;&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>            index_mergbam.inports[<span style="color:#a31515">&#39;bam&#39;</span>] = mergbam.outport(<span style="color:#a31515">&#39;bam&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Step 5a in [1]------------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span>            local_realign = shell(<span style="color:#a31515">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            java -Xmx2g -jar /sw/apps/bioinfo/GATK/1.5.21/GenomeAnalysisTK.jar
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -I &lt;i:bam&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -R </span><span style="color:#a31515">{ref}</span><span style="color:#a31515">
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -T RealignerTargetCreator
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -o &lt;o:intervals:&lt;i:bam&gt;.intervals&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            &#39;&#39;&#39;</span>.format(
</span></span><span style="display:flex;"><span>               ref=REF))
</span></span><span style="display:flex;"><span>            local_realign.inports[<span style="color:#a31515">&#39;bam&#39;</span>] = mergbam.outport(<span style="color:#a31515">&#39;bam&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Step 5b in [1]-----------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span>            actual_realign = shell(<span style="color:#a31515">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            java -Xmx2g -jar /sw/apps/bioinfo/GATK/1.5.21/GenomeAnalysisTK.jar
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -I &lt;i:bam&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -R </span><span style="color:#a31515">{ref}</span><span style="color:#a31515">
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -T IndelRealigner
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -o &lt;o:realigned_bam:&lt;i:intervals&gt;.realign.bam&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -targetIntervals &lt;i:intervals&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                # &lt;o:realigned_bai:&lt;i:intervals&gt;.realign.bai&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            &#39;&#39;&#39;</span>.format(
</span></span><span style="display:flex;"><span>                ref=REF))
</span></span><span style="display:flex;"><span>            actual_realign.inports[<span style="color:#a31515">&#39;bam&#39;</span>] = mergbam.outport(<span style="color:#a31515">&#39;bam&#39;</span>)
</span></span><span style="display:flex;"><span>            actual_realign.inports[<span style="color:#a31515">&#39;intervals&#39;</span>] = local_realign.outport(<span style="color:#a31515">&#39;intervals&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Step 5c in [1]-----------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span>            mark_dupes = shell(<span style="color:#a31515">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            java -Xmx2g -jar /sw/apps/bioinfo/picard/1.69/kalkyl/MarkDuplicates.jar &#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                INPUT=&lt;i:bam&gt; &#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                OUTPUT=&lt;o:marked_bam:&lt;i:bam&gt;.marked.bam&gt; &#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                METRICS_FILE=&lt;o:metrics:&lt;i:bam&gt;.marked.metrics&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            &#39;&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>            mark_dupes.inports[<span style="color:#a31515">&#39;bam&#39;</span>] = actual_realign.outport(<span style="color:#a31515">&#39;realigned_bam&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Step 5d in [1], Index bam (picard does not do that automatically)---------------</span>
</span></span><span style="display:flex;"><span>            index_marked_bam = shell((<span style="color:#a31515">&#39;java -Xmx2g -jar /sw/apps/bioinfo/picard/1.69/kalkyl/BuildBamIndex.jar &#39;</span>
</span></span><span style="display:flex;"><span>                                 <span style="color:#a31515">&#39;INPUT=&lt;i:bam&gt; &#39;</span>
</span></span><span style="display:flex;"><span>                                 <span style="color:#a31515">&#39;# &lt;o:bai:&lt;i:bam:.bam|.bai&gt;&gt;&#39;</span>))
</span></span><span style="display:flex;"><span>            index_marked_bam.inports[<span style="color:#a31515">&#39;bam&#39;</span>] = mark_dupes.outport(<span style="color:#a31515">&#39;marked_bam&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Step 5e in [1], quality recalibration with GATK---------------------------------</span>
</span></span><span style="display:flex;"><span>            count_covar = shell(<span style="color:#a31515">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            java -Xmx2g -jar /sw/apps/bioinfo/GATK/1.5.21/GenomeAnalysisTK.jar
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -T CountCovariates -I &lt;i:bam&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -R </span><span style="color:#a31515">{ref}</span><span style="color:#a31515">
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -knownSites </span><span style="color:#a31515">{sites}</span><span style="color:#a31515">
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -cov ReadGroupCovariate
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -cov CycleCovariate
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -cov DinucCovariate
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -cov QualityScoreCovariate
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -recalFile &lt;o:covariate:&lt;i:bam&gt;.covar&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            &#39;&#39;&#39;</span>.format(
</span></span><span style="display:flex;"><span>                ref=REF,
</span></span><span style="display:flex;"><span>                sites=KNOWNSITES))
</span></span><span style="display:flex;"><span>            count_covar.inports[<span style="color:#a31515">&#39;bam&#39;</span>] = mark_dupes.outport(<span style="color:#a31515">&#39;marked_bam&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Step 5f in [1]-----------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span>            table_recalib = shell(<span style="color:#a31515">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            java -Xmx2g -jar /sw/apps/bioinfo/GATK/1.5.21/GenomeAnalysisTK.jar
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -T TableRecalibration
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -I &lt;i:bam&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -R </span><span style="color:#a31515">{ref}</span><span style="color:#a31515">
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -recalFile &lt;i:calib&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">                -o &lt;o:calibrated_bam:&lt;i:calib&gt;.bam&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">            &#39;&#39;&#39;</span>.format(ref=REF))
</span></span><span style="display:flex;"><span>            table_recalib.inports[<span style="color:#a31515">&#39;bam&#39;</span>] = mark_dupes.outport(<span style="color:#a31515">&#39;marked_bam&#39;</span>)
</span></span><span style="display:flex;"><span>            table_recalib.inports[<span style="color:#a31515">&#39;calib&#39;</span>] = count_covar.outport(<span style="color:#a31515">&#39;covariate&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">yield</span> table_recalib
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> __name__ == <span style="color:#a31515">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    luigi.run()
</span></span></code></pre></div><p>I think in this example it becomes clear that the actual <strong>data flow</strong>
in the system, is much more intricate than just the <strong>dependencies
between tasks,</strong> and that the latter, tasks dependencies only, don't
naturally capture the detail of the problem in practice. Thus, to get
the proper level of control, we need to be able to define the data flow
in the system, from input/inport of one task, to output/outport of
another. The task dependencies can easily be computed by the dataflow
wiring anyway!</p>
<h3 id="take-home-message">Take home message</h3>
<p>​So, please, tool makers, remember:</p>
<ul>
<li>Tasks need to support multiple, explicitly named inputs and outputs
(&quot;in-ports&quot; and &quot;out-ports&quot; in <a href="http://en.wikipedia.org/wiki/Flow-based_programming">Flow-based
programming</a>
lingo).</li>
<li>The dependency graph definition should define connections between
inputs and outputs, not between tasks.</li>
</ul>
<p>So again, in summary: <strong>Let's focus more on [allowing to define] the
data flow in the system, than the dependencies between tasks</strong>.</p>

  


  </main>
  <footer>
    <p>Copyright &copy; 2024 Living Systems. All rights reserved.</p>

  </footer>
</body>
</html>
