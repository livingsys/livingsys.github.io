<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Flow-Based Programming on Living Systems_</title>
    <link>https://livesys.se/tags/flow-based-programming/</link>
    <description>Recent content in Flow-Based Programming on Living Systems_</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Feb 2021 16:24:00 +0100</lastBuildDate>
    <atom:link href="https://livesys.se/tags/flow-based-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Composability in functional and flow-based programming</title>
      <link>https://livesys.se/posts/composability-in-functional-and-flow-based-programming/</link>
      <pubDate>Fri, 12 Feb 2021 16:24:00 +0100</pubDate>
      <guid>https://livesys.se/posts/composability-in-functional-and-flow-based-programming/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;&#xA;&lt;p&gt;An area where I&amp;rsquo;m not so happy with some things I&amp;rsquo;ve seen in FP, is&#xA;composability.&lt;/p&gt;&#xA;&lt;p&gt;In my view, a well designed system or langauge should make functions (or&#xA;other smallest unit of computation) more easily composable, not less.&lt;/p&gt;&#xA;&lt;p&gt;What strikes me as one of the biggest elephants in the room regarding&#xA;FP, is that typical functions compose fantastically as long as you are&#xA;working with a single input argument, and a single output for each&#xA;function application, but as soon as you start taking multiple input&#xA;arguments and returned outputs though, you tend to end up with very&#xA;messy trees of function application. Even handy techniques such as&#xA;currying tend to get overly complex if you want to handle all the&#xA;possible downstream dataflow paths in a structured way.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Structured Go-routines or framework-less Flow-Based Programming inÂ Go</title>
      <link>https://livesys.se/posts/structured-go-routines-or-framework-less-flow-based-programming-in-go/</link>
      <pubDate>Sat, 02 Mar 2019 13:52:00 +0100</pubDate>
      <guid>https://livesys.se/posts/structured-go-routines-or-framework-less-flow-based-programming-in-go/</guid>
      <description>&lt;p&gt;I was so happy the other day to find someone else who found the great&#xA;benefits of a little pattern for how to structure pipeline-heavy&#xA;programs in Go, which I described in a few posts before. I have been&#xA;surprised to not find more people using this kind of pattern, which has&#xA;been so extremely helpful to us, so I thought to take this opportunity&#xA;to re-iterate it again, in the hopes that more people might get aware of&#xA;it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How I would like to write Go programs</title>
      <link>https://livesys.se/posts/how-i-would-like-to-write-golang/</link>
      <pubDate>Sat, 18 Jul 2015 02:34:00 +0200</pubDate>
      <guid>https://livesys.se/posts/how-i-would-like-to-write-golang/</guid>
      <description>&lt;p&gt;&lt;p class=&#34;image&#34;&gt;&#xA;    &lt;img src=&#34;selection_301.png&#34; alt=&#34;&#34;  /&gt;&#xA;&lt;/p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;Some time ago I got a &lt;a href=&#34;http://blog.gopheracademy.com/composable-pipelines-pattern&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;post published on&#xA;GopherAcademy&lt;/a&gt;&#xA;,&#xA;outlining in detail how I think a &lt;a href=&#34;http://www.jpaulmorrison.com/fbp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;flow-based&#xA;programming&lt;/a&gt;&#xA; inspired syntax can&#xA;strongly help to create clearer, easier-to-maintain, and more&#xA;declarative Go programs.&lt;/p&gt;&#xA;&lt;p&gt;These ideas have since became clearer, and we (&lt;a href=&#34;http://twitter.com/ola_spjuth&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ola&#xA;Spjuth&lt;/a&gt;&#xA;&amp;rsquo;s &lt;a href=&#34;http://www.farmbio.uu.se/research/researchgroups/pb/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;research group at&#xA;pharmbio&lt;/a&gt;&#xA;) have&#xA;successfully used them to make the workflow syntax for&#xA;&lt;a href=&#34;https://github.com/spotify/luigi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Luigi&lt;/a&gt;&#xA; (Spotify&amp;rsquo;s great workflow&#xA;engine by &lt;a href=&#34;http://twitter.com/fulhack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Erik Bernhardsson&lt;/a&gt;&#xA; &amp;amp; co)&#xA;workflows easier, as implemented in the &lt;a href=&#34;https://github.com/samuell/sciluigi#readme&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SciLuigi helper&#xA;library&lt;/a&gt;&#xA;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>FBP inspired data flow syntax: The missing piece for the success of functional programming?</title>
      <link>https://livesys.se/posts/fbp-data-flow-syntax/</link>
      <pubDate>Thu, 16 Jul 2015 17:13:00 +0200</pubDate>
      <guid>https://livesys.se/posts/fbp-data-flow-syntax/</guid>
      <description>&lt;p&gt;&lt;p class=&#34;image&#34;&gt;&#xA;    &lt;img src=&#34;selection_288.png&#34; alt=&#34;&#34;  /&gt;&#xA;&lt;/p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;Often when I suggest people have a look at &lt;a href=&#34;http://www.jpaulmorrison.com/fbp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Flow-based&#xA;Programming&lt;/a&gt;&#xA; (FBP) or &lt;a href=&#34;https://en.wikipedia.org/wiki/Dataflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Data&#xA;Flow&lt;/a&gt;&#xA; for one reason or another,&#xA;people are often put off by the strong connection between these concepts&#xA;and graphical programming. That is, the idea that programs will be&#xA;easier to understand if expressed and developed in a visual notation.&lt;/p&gt;&#xA;&lt;p&gt;This is unfortunate, since I think this is in no way the core benefit of&#xA;FBP or Data Flow, although it is a nice side-effect for those who prefer&#xA;it. For example, I personally mostly prefer working with text over a&#xA;graphical notation, for productivity reasons.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flow-based programming and Erlang style message passing - A Biology-inspired idea of how they fit together</title>
      <link>https://livesys.se/posts/flowbased-vs-erlang-message-passing/</link>
      <pubDate>Sat, 13 Jun 2015 14:25:00 +0200</pubDate>
      <guid>https://livesys.se/posts/flowbased-vs-erlang-message-passing/</guid>
      <description>&lt;p&gt;&lt;strong&gt;I think Erlang/Elixir fits great as control plane or&#xA;service-to-service messaging layer for distributing services built with&#xA;flow-based programming&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;p class=&#34;image&#34;&gt;&#xA;    &lt;img src=&#34;erlang_logo.png&#34; alt=&#34;Erlang logo&#34;  class=&#34;align_right&#34; /&gt;&#xA;&lt;/p&gt;&#xA;Just&#xA;back from a one day visit to &lt;a href=&#34;http://www.erlang-factory.com/euc2015&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Erlang User&#xA;Conference&lt;/a&gt;&#xA;. I find the&#xA;&lt;a href=&#34;http://www.erlang.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Erlang&lt;/a&gt;&#xA; virtual machine fascinating. And with&#xA;the new &lt;a href=&#34;http://elixir-lang.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Elixir language&lt;/a&gt;&#xA; built on top of it to&#xA;fix some of the pain points with &lt;em&gt;Erlang the language&lt;/em&gt;, the eco-system&#xA;has got even more interesting.&lt;/p&gt;&#xA;&lt;p&gt;What I find exciting about Erlang/Elixir and its virtual machine, is its&#xA;ability to utilize multiple CPU:s on computers, and doing this across&#xA;multiple computers, in what is commonly referred to as &amp;ldquo;distributed&#xA;computing&amp;rdquo;. &lt;p class=&#34;image&#34;&gt;&#xA;    &lt;img src=&#34;fbp_general_interactive_application.png&#34; alt=&#34;Flow-based programming example. Image from&#xA;http://jpaulmorrison.com/fbp/examples.html&#34;  class=&#34;align_right&#34; /&gt;&#xA;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Workflow tool makers: Allow defining data flow, not just task dependencies</title>
      <link>https://livesys.se/posts/workflows-dataflow-not-task-deps/</link>
      <pubDate>Wed, 10 Jun 2015 12:03:00 +0200</pubDate>
      <guid>https://livesys.se/posts/workflows-dataflow-not-task-deps/</guid>
      <description>&lt;h3 id=&#34;upsurge-in-workflow-tools&#34;&gt;Upsurge in workflow tools&lt;/h3&gt;&#xA;&lt;p&gt;&lt;p class=&#34;image&#34;&gt;&#xA;    &lt;img src=&#34;selection_201.png&#34; alt=&#34;Workflow tool&#xA;logos&#34;  class=&#34;align_right&#34; /&gt;&#xA;&lt;/p&gt;&#xA;There&#xA;seem to be a little upsurge in light-weight - often python-based -&#xA;workflow tools for data pipelines in the last couple of years:&#xA;Spotify&amp;rsquo;s &lt;a href=&#34;https://github.com/spotify/luigi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Luigi&lt;/a&gt;&#xA;, OpenStack&amp;rsquo;s&#xA;&lt;a href=&#34;https://wiki.openstack.org/wiki/Mistral&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mistral&lt;/a&gt;&#xA;, Pinterest&amp;rsquo;s&#xA;&lt;a href=&#34;https://github.com/pinterest/pinball&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pinball&lt;/a&gt;&#xA;, and recently AirBnb&amp;rsquo;s&#xA;&lt;a href=&#34;https://github.com/airbnb/airflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Airflow&lt;/a&gt;&#xA;, to name a few. These are&#xA;all interesting tools, and it is an interesting trend for us at&#xA;&lt;a href=&#34;http://www.farmbio.uu.se/research/researchgroups/pb/?languageId=1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pharmbio&lt;/a&gt;&#xA;,&#xA;who try to see how we can use workflow tools to automate bio- and&#xA;cheminformatics tasks on compute clusters.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Profiling and creating call graphs for Go programs</title>
      <link>https://livesys.se/posts/profiling-and-call-graphs-for-golang/</link>
      <pubDate>Thu, 08 Aug 2013 01:13:00 +0200</pubDate>
      <guid>https://livesys.se/posts/profiling-and-call-graphs-for-golang/</guid>
      <description>&lt;p&gt;In trying to get my head around the code of the very interesting&#xA;&lt;a href=&#34;https://github.com/trustmaster/goflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GoFlow&lt;/a&gt;&#xA; library, (for flow-based&#xA;programming in Go), and the accompanying &lt;a href=&#34;https://github.com/samuell/blow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;flow-based bioinformatics&#xA;library&lt;/a&gt;&#xA; I started hacking on, I needed&#xA;to get some kind of visualization (like a call graph) &amp;hellip; something&#xA;like this:&lt;/p&gt;&#xA;&lt;p&gt;&lt;p class=&#34;image&#34;&gt;&#xA;    &lt;img src=&#34;basecompl_blow_callgraph_1.png&#34; alt=&#34;Call graph&#34;  /&gt;&#xA;&lt;/p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;(And in the end, that is what I got &amp;hellip; read on &amp;hellip; ) :)&lt;/p&gt;&#xA;&lt;p&gt;I then found out about the go tool pprof command, for which the Go team&#xA;published a &lt;a href=&#34;http://blog.golang.org/profiling-go-programs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt;&#xA; on&#xA;&lt;a href=&#34;http://blog.golang.org/profiling-go-programs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;&#xA;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
