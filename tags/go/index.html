<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Go | Living Systems_</title>

      <link rel="stylesheet" href="/css/main.min.8c956930b166a95a5077b8a42b62d0a3d6bbc1b601d884ea91af464ca5ffc3bf.css" integrity="sha256-jJVpMLFmqVpQd7ikK2LQo9a7wbYB2ITqka9GTKX/w78=" crossorigin="anonymous">


      <script src="/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js" integrity="sha256-I80MfYNyY7nq65buLZzPopadqj&#43;gD6HB/ocBqbhyUaE=" crossorigin="anonymous"></script>

<link rel="alternate" type="application/rss+xml" href="/tags/go/index.xml" title="Living Systems_">


</head>
<body>
  <header>
    <h1>Living Systems_</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    <li>
      <a href="/about/">About</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Go</h1>
  
  
    
    <a href="/posts/golang-for-bioinformatics/"><img src="/posts/golang-for-bioinformatics//gopherbinfie.jpg" class="post-img-list"></a>
    
    <h2><a href="/posts/golang-for-bioinformatics/">Why didn&#39;t Go get a breakthrough in bioinformatics (yet)?</a></h2>
    As we are - according to some expert opinions - living in the Century of Biology, I found it interesting to reflect on Go&rsquo;s usage within the field.
Go has some great features that make it really well suited for biology, such as:
A relatively simple language that can be learned in a short time even for people without a CS background. This is super important aspect for biologists. Fantastic support for cross-compilation into all major computer architectures and operating systems, as static, self-sufficient executables making it extremely simple to deploy tools, something that can&rsquo;t be said about the currently most popular bio language, Python.
  
    
    <a href="/posts/crystal-concurrency-easier-syntax-than-golang/"><img src="/posts/crystal-concurrency-easier-syntax-than-golang//selection_161-1.png" class="post-img-list"></a>
    
    <h2><a href="/posts/crystal-concurrency-easier-syntax-than-golang/">Crystal: Go-like concurrency with easier syntax</a></h2>
    I have been playing around a lot with concurrency in Go over the years, resulting in libraries such as SciPipe , FlowBase and rdf2smw . My main motivation for looking into Go has been the possibility to use it as a more performant, scaleable and type-safe alternative to Python for data heavy scripting tasks in bioinformatics and other fields I&rsquo;ve been dabbling in. Especially as it makes it so easy to write concurrent and parallel code in it.
  
    
    <a href="/posts/go-test-coverage-in-browser/"><img src="/posts/go-test-coverage-in-browser//selection_150.png" class="post-img-list"></a>
    
    <h2><a href="/posts/go-test-coverage-in-browser/">Viewing Go test coverage in the browser with one command</a></h2>
    Go has some really nice tools for running tests and analyzing code. One of these functionalities is that you can generate coverage information when running tests, that can later be viewed in a browser using the go tool cover command. It turns out though, since doing it requires executing multiple commands after each other, it might be hard to remember the exact commands.
To this end, I created a bash alias that does everything in one command, gocov.
  
    
    <a href="/posts/structured-go-routines-or-framework-less-flow-based-programming-in-go/"><img src="/posts/structured-go-routines-or-framework-less-flow-based-programming-in-go//selection_999_136.png" class="post-img-list"></a>
    
    <h2><a href="/posts/structured-go-routines-or-framework-less-flow-based-programming-in-go/">Structured Go-routines or framework-less Flow-Based Programming inÂ Go</a></h2>
    I was so happy the other day to find someone else who found the great benefits of a little pattern for how to structure pipeline-heavy programs in Go, which I described in a few posts before. I have been surprised to not find more people using this kind of pattern, which has been so extremely helpful to us, so I thought to take this opportunity to re-iterate it again, in the hopes that more people might get aware of it.
  
    
    <h2><a href="/posts/parsing-drugbank-xml-or-any-large-xml-file-in-streaming-mode-in-go/">Parsing DrugBank XML (or any large XML file) in streaming mode in Go</a></h2>
    I had a problem in which I thought I needed to parse the full DrugBank dataset, which comes as a (670MB) XML file (For open access papers describing DrugBank, see: [1], [2], [3] and [4]). It turned out what I needed was available as CSV files under &ldquo;Structure External Links &rdquo;. There is probably still some other uses of this approach though, as the XML version of DrugBank seems to contain a lot more information in a single format.
  
    
    <a href="/posts/equation-centric-dataflow-programming-in-go/"><img src="/posts/equation-centric-dataflow-programming-in-go//loan.gif" class="post-img-list"></a>
    
    <h2><a href="/posts/equation-centric-dataflow-programming-in-go/">Equation-centric dataflow programming in Go</a></h2>
    Mathematical notation and dataflow programming Even though computations done on computers are very often based on some type of math, it is striking that the notation used in math to express equations and relations is not always very readily converted into programming code. Outside of purely symbolic programming languages like sage math or the (proprietary) Wolfram language , there seem to always be quite a divide between the mathematical notation and the numerical implementation.
  
    
    <a href="/posts/golang-growing-in-bioinformatics-workflows/"><img src="/posts/golang-growing-in-bioinformatics-workflows//gopher_thinking_workflows.png" class="post-img-list"></a>
    
    <h2><a href="/posts/golang-growing-in-bioinformatics-workflows/">Go is growing in bioinformatics workflow tools</a></h2>
    TL;DR: We wrote a post on gopherdata.io, about the growing ecosystem of Go-based workflow tools in bioinformatics. Go read it here It is interesting to note how Google&rsquo;s Go programming language seems to increase in popularity in bioinformatics.
Just to give a sample of some of the Go based bioinformatics tools I&rsquo;ve stumbled upon, there is since a few years back, the biogo library , providing common functionality for bioinformatics tasks.
  
    
    <h2><a href="/posts/range-over-multiple-go-channels/">(Almost) ranging over multiple Go channels simultaneously</a></h2>
    Thus, optimally, one would want to use Go&rsquo;s handy range keyword for looping over multiple channels, since range takes care of closing the for-loop at the right time (when the inbound channel is closed). So something like this (N.B: non-working code!):
for a, b, c := range chA, chB, chC { doSomething(a, b, c) } Unfortunately this is not possible, and probably for good reason (how would it know whether to close the loop when the first, or all of the channels are closed?
  
    
    <a href="/posts/first-production-workflow-run-with-scipipe/"><img src="/posts/first-production-workflow-run-with-scipipe//terminal_411.png" class="post-img-list"></a>
    
    <h2><a href="/posts/first-production-workflow-run-with-scipipe/">First production run with SciPipe - A Go-based scientific workflow tool</a></h2>
    Today marked the day when we ran the very first production workflow with SciPipe , the Go -based scientific workflow tool we&rsquo;ve been working on over the last couple of years. Yay! :)
This is how it looked (no fancy GUI or such yet, sorry):
The first result we got in this very very first job was a list of counts of ligands (chemical compounds) in the ExcapeDB dataset (download here ) interacting with the 44 protein/gene targets identified by Bowes et al as a good baseline set for identifying hazardous side-effects effects in the body (that is, any chemical compounds binding these proteins, will never become an approved drug).
  
    
    <a href="/posts/launching-kubernetes-jobs-from-the-go-api-notes-from-a-beginner/"><img src="/posts/launching-kubernetes-jobs-from-the-go-api-notes-from-a-beginner//selection_117.png" class="post-img-list"></a>
    
    <h2><a href="/posts/launching-kubernetes-jobs-from-the-go-api-notes-from-a-beginner/">Notes on launching kubernetes jobs from the Go API</a></h2>
    This post is also published on medium My current work at pharmb.io entails adding kubernetes support to my light-weight Go-based scientific workflow engine, scipipe (kubernetes, or k8s for short, is Google&rsquo;s open source project for orchestrating container based compute clusters), which should take scipipe from a simple &ldquo;run it on your laptop&rdquo; workflow system with HPC support still in the work, to something that can power scientific workflows on any set of networked computers that can run kubernetes, which is quite a few (AWS, GCE, Azure, your Raspberry Phi cluster etc etc).
  
    
    <h2><a href="/posts/the-best-of-go-d-and-rust/">Combining the best of Go, D and Rust?</a></h2>
    I&rsquo;ve been following the development of D , Go and Rust (and also FreePascal for some use cases ) for some years (been into some benchmarking for bioinfo tasks ), and now we finally have three (four, with fpc) stable statically compiled languages with some momentum behind them, meaning they all are past 1.0.
While I have went with Go for current projects , I still have a hard time &ldquo;totally falling in love&rdquo; with any single of these languages.
  
    
    <a href="/posts/how-i-would-like-to-write-golang/"><img src="/posts/how-i-would-like-to-write-golang//selection_301.png" class="post-img-list"></a>
    
    <h2><a href="/posts/how-i-would-like-to-write-golang/">How I would like to write Go programs</a></h2>
    Some time ago I got a post published on GopherAcademy , outlining in detail how I think a flow-based programming inspired syntax can strongly help to create clearer, easier-to-maintain, and more declarative Go programs.
These ideas have since became clearer, and we (Ola Spjuth &rsquo;s research group at pharmbio ) have successfully used them to make the workflow syntax for Luigi (Spotify&rsquo;s great workflow engine by Erik Bernhardsson &amp; co) workflows easier, as implemented in the SciLuigi helper library .
  
    
    <a href="/posts/patterns-for-composable-concurrent-pipelines-in-go/"><img src="/posts/patterns-for-composable-concurrent-pipelines-in-go//selection_212.png" class="post-img-list"></a>
    
    <h2><a href="/posts/patterns-for-composable-concurrent-pipelines-in-go/">Patterns for composable concurrent pipelines in Go</a></h2>
    I realize I didn&rsquo;t have a link to my blog on Gopher Academy , on patterns for compoasable concurrent pipelines in Go(lang), so here it goes:
blog.gopheracademy.com/composable-pipelines-pattern 
  
    
    <h2><a href="/posts/smallest-pipeable-go-program/">The smallest pipeable go program</a></h2>
    Edit: My original suggested way further below in the post is no way the &ldquo;smallest pipeable&rdquo; program, instead see this example (Credits: Axel Wagner ):
package main import ( &#34;io&#34; &#34;os&#34; ) func main() { io.Copy(os.Stdout, os.Stdin) } &hellip; or (credits: Roger Peppe ):
package main import ( &#34;bufio&#34; &#34;fmt&#34; &#34;os&#34; ) func main() { for scan := bufio.NewScanner(os.Stdin); scan.Scan(); { fmt.Printf(&#34;%s\n&#34;, scan.Text()) } } Ah, I just realized that the &ldquo;smallest pipeable&rdquo; Go (lang) program is rather small, if using my little library of minimalistic streaming components .
  
    
    <a href="/posts/profiling-and-call-graphs-for-golang/"><img src="/posts/profiling-and-call-graphs-for-golang//basecompl_blow_callgraph_crop.png" class="post-img-list"></a>
    
    <h2><a href="/posts/profiling-and-call-graphs-for-golang/">Profiling and creating call graphs for Go programs</a></h2>
    In trying to get my head around the code of the very interesting GoFlow library, (for flow-based programming in Go), and the accompanying flow-based bioinformatics library I started hacking on, I needed to get some kind of visualization (like a call graph) &hellip; something like this:
(And in the end, that is what I got &hellip; read on &hellip; ) :)
I then found out about the go tool pprof command, for which the Go team published a blog post on here .
  

  </main>
  <footer>
    <p>Copyright &copy; 2024 Living Systems. All rights reserved.</p>

  </footer>
</body>
</html>
